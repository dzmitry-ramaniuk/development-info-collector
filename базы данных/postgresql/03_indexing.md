# Индексация и доступ к данным в PostgreSQL


## Содержание

1. [1. Зачем нужны индексы](#1-зачем-нужны-индексы)
2. [2. Основные типы индексов](#2-основные-типы-индексов)
3. [3. Проектирование индексов](#3-проектирование-индексов)
4. [4. Особенности конкретных типов](#4-особенности-конкретных-типов)
5. [5. Обслуживание и мониторинг](#5-обслуживание-и-мониторинг)
6. [6. Стратегии для специфических нагрузок](#6-стратегии-для-специфических-нагрузок)
7. [7. Диагностика производительности](#7-диагностика-производительности)
8. [8. Индексы и транзакции](#8-индексы-и-транзакции)
9. [9. Автоматизация и инструментирование](#9-автоматизация-и-инструментирование)

## 1. Зачем нужны индексы
- Ускоряют поиск и сортировку, уменьшая количество страниц, читаемых с диска.
- Поддерживают ограничения (`PRIMARY KEY`, `UNIQUE`, `EXCLUDE`).
- Влияют на планировщик: актуальная статистика и селективность определяют, выберет ли сервер последовательное чтение или индекс.
- Каждый индекс — компромисс: ускоряет чтение, но замедляет запись и требует обслуживания.

## 2. Основные типы индексов
| Тип | Особенности | Применение |
|-----|-------------|------------|
| B-tree | Балансированное дерево, поддерживает `=`, `<`, `>`, `BETWEEN`, `ORDER BY` | Универсальный индекс, первичные ключи |
| Hash | Только сравнение на равенство, компактный | Кэширование ключ-значение, точные соответствия |
| GIN | Инвертированный индекс | JSONB, массивы, полнотекстовый поиск |
| GiST | Обобщённое дерево поиска | Геометрия, диапазоны, FTS, `ltree` |
| SP-GiST | Разреженные структуры (trie, quadtree) | Телефонные номера, IP-адреса, геоданные |
| BRIN | Сводная статистика по блокам | Логи, временные ряды, большие последовательные таблицы |
| BLOOM | Вероятностный фильтр (расширение) | Ускорение проверок `WHERE col IN (...)` для широких таблиц |

## 3. Проектирование индексов
- **Выбор столбцов**: оценивайте кардинальность (`SELECT COUNT(DISTINCT col)`). Высокая селективность — кандидаты на индексы.
- **Порядок столбцов**: в составных индексах условия должны начинаться с левого префикса.
- **Фильтры**: используйте частичные индексы (`WHERE status = 'active'`). Они меньше и быстрее обновляются.
- **Функциональные индексы**: `CREATE INDEX ON table ((lower(name)));` — полезно при поиске по выражениям.
- **Покрывающие индексы**: `INCLUDE (col2, col3)` для `Index Only Scan`. Требуют актуальной Visibility Map.
- **Сравнение вариантов**: `EXPLAIN (COSTS, VERBOSE)` и `hypopg_create_index` (расширение) помогают оценить эффект индекса до его создания.

## 4. Особенности конкретных типов
- **B-tree**: поддерживает сортировку, `ORDER BY`, `DISTINCT`. Следите за коллапсом значений (`fillfactor`).
- **GIN**:
  - Имеет структуру `fastupdate`, накапливающую pending list; при высоких обновлениях настройте `gin_pending_list_limit` или периодический `VACUUM`.
  - Используйте классы операторов (`jsonb_ops`, `jsonb_path_ops`) в зависимости от запросов.
- **GiST**: зависит от операторного класса. Для геоданных PostGIS предоставляет собственные классы.
- **BRIN**: почти не ускоряет точечные запросы, но эффективен при данных, упорядоченных по времени. Комбинируйте с автоматической реорганизацией (`VACUUM` и `REINDEX`).
- **SP-GiST**: хорош при иерархических префиксах (телефоны, IP). Требует анализа паттернов запросов.

## 5. Обслуживание и мониторинг
- **Статистика**: `pg_stat_user_indexes` (колонки `idx_scan`, `idx_tup_read`, `idx_tup_fetch`) показывает использование. Низкие значения — сигнал к пересмотру индекса.
- **Размеры**: `pg_relation_size('idx_name')`, `pg_indexes_size('table')`, `pg_total_relation_size`.
- **Фрагментация**: `pgstatindex` (расширение `pageinspect`) помогает выявить bloat.
- **Перестроение**: `REINDEX [CONCURRENTLY]` для исправления повреждений и снижения bloat. Для больших индексов используйте `REINDEX CONCURRENTLY`, чтобы не блокировать операции.
- **Автоочистка**: `autovacuum` поддерживает статистику и удаляет мёртвые записи, влияющие на индексы.
- **Fillfactor**: понижайте `fillfactor` на таблицах с активными обновлениями, чтобы избежать разделения страниц.

## 6. Стратегии для специфических нагрузок
- **OLTP**: минимум необходимых индексов, фокус на `WHERE` и `JOIN`. Рассмотрите составные индексы для частых запросов.
- **Аналитика/OLAP**: добавляйте индексы для фильтров и агрегаций; используйте `partial index` для «горячих» данных и BRIN для архивных.
- **Полнотекстовый поиск**: `CREATE INDEX ON docs USING GIN (to_tsvector('russian', content));`. Храните лексемы в отдельном столбце для ускорения.
- **JSONB**: комбинируйте `GIN` по выражениям (`(data->>'status')`) и частичные индексы.
- **Диапазоны и геоданные**: GiST/SP-GiST позволяют использовать операторы `&&`, `@>`, `<<`, `>>`.

## 7. Диагностика производительности
- Используйте `EXPLAIN (ANALYZE, BUFFERS)` для оценки доли чтений по индексу vs. последовательного сканирования.
- При подозрении на устаревшие статистики запускайте `ANALYZE` или увеличивайте `default_statistics_target` для конкретных столбцов (`ALTER TABLE ... ALTER COLUMN ... SET STATISTICS 200`).
- Следите за `heap_blks_read` vs. `heap_blks_hit` в `pg_statio_user_tables`, чтобы оценить эффективность кеша.
- Для GIN/GiST анализируйте `pg_stat_database_conflicts` и `pg_stat_user_indexes` на предмет конфликтов и числа recheck.

## 8. Индексы и транзакции
- Индексы создаются в транзакции; `CREATE INDEX CONCURRENTLY` запускает несколько фаз и требует повторного запуска при ошибке.
- При массовой загрузке данных быстрее загрузить без индексов и создать их после (`maintenance_work_mem`, `synchronous_commit=off` в тестовой среде).
- Для соблюдения уникальности используйте `DEFERRABLE INITIALLY DEFERRED`, если уникальность должна проверяться при `COMMIT`.

## 9. Автоматизация и инструментирование
- Скрипты анализа (например, `check_pgactivity`, `pg_index_usage`) собирают статистику и предлагают рекомендации.
- Расширения `hypopg`, `auto_explain`, `pg_qualstats` помогают выявлять выражения и фильтры, требующие индексов.
- Регулярные отчёты (`pg_stat_statements`, `pgBadger`) показывают запросы без индекса или с низкой селективностью.

Правильная стратегия индексации обеспечивает баланс между скоростью чтения и затратами на запись, поддерживая устойчивую производительность базы данных.
