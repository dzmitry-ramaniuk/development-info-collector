# Типы данных и моделирование в PostgreSQL

## 1. Общие принципы выбора типов
- **Минимально достаточный размер**: уменьшает объём хранения, улучшает попадание в кеш и ускоряет индексацию.
- **Чёткие ограничения**: используйте `CHECK`, домены (`CREATE DOMAIN`), перечисления (`ENUM`) для валидации бизнес-правил.
- **Нормализация vs. гибкость**: комбинация реляционных структур с `jsonb`, массивами и `hstore` позволяет балансировать между строгой схемой и гибкими атрибутами.
- **Интернационализация**: учитывайте кодировки (`UTF-8` по умолчанию) и сортировку (`COLLATE`, `C` vs. `icu`), влияющие на сравнение строк.
- **Бинарная совместимость**: типы должны соответствовать форматам клиентов (например, `timestamp` без часового пояса может трактоваться по-разному).

## 2. Числовые типы
| Тип | Диапазон | Размер | Применение |
|-----|---------|--------|------------|
| `smallint` | ±32K | 2 байта | Флаги, компактные справочники |
| `integer` | ±2 млрд | 4 байта | Основной тип для счётчиков |
| `bigint` | ±9e18 | 8 байт | Денормализованные ключи, события |
| `numeric(p, s)` | Задаётся вручную | До 131072 цифр | Финансовые расчёты, точные вычисления |
| `real`, `double precision` | IEEE-754 | 4/8 байт | Аналитика, ML, расчёты с плавающей точкой |
| `serial`, `bigserial`, `identity` | Автогенерация | 4/8 байт | Псевдотипы для первичных ключей |

**Практика**:
- Для денежных значений используйте `numeric(18,2)` или модуль `money` (учитывая локализацию).
- При работе с большим количеством счётчиков рассматривайте `identity`-столбцы вместо `serial`, чтобы получать преимущества `ALTER TABLE ... SET GENERATED`.
- Если требуется UUID как первичный ключ, используйте тип `uuid` и генераторы `gen_random_uuid()` (`pgcrypto`).

## 3. Строковые и текстовые
- `text` — основной тип для неограниченных строк. Не ограничивайте `varchar`, если нет бизнес-причины.
- `varchar(n)` — задаёт верхнюю границу, полезно для контрактов с внешними системами.
- `char(n)` — фиксированная длина, часто приводит к заполнению пробелами; избегайте без необходимости.
- `citext` — регистронезависимые сравнения (расширение `citext`).
- `tsvector` и `tsquery` — полнотекстовый поиск с поддержкой словарей, нормализации, ранжирования (`rank_cd`, `ts_rank`).
- `text[]`, `varchar[]` — массивы строк; требуют аккуратной индексации (`GIN`).

**Советы**:
- Устанавливайте `collation` при создании столбцов, если нужно специфическое сравнение (`COLLATE "ru_RU"`).
- Для хранения JSON используйте `jsonb` и оператор `@>` для поиска по ключам.

## 4. Дата и время
- `timestamp without time zone` (`timestamp`) — хранит локальное время; избегайте в распределённых системах.
- `timestamp with time zone` (`timestamptz`) — хранит UTC и отображает в локальном часовом поясе клиента.
- `date`, `time` — календарные значения без времени/даты.
- `interval` — длительность, поддерживает сложение с датой.
- Диапазоны (`tsrange`, `tstzrange`, `daterange`) — удобны для расписаний, бронирований, автоматического контроля пересечений (`&&`, `@>`, `-|-`).
- Функции `clock_timestamp()`, `statement_timestamp()`, `transaction_timestamp()` различаются по моменту фиксации значения.

**Практика**:
- При хранении временных рядов используйте партиционирование по дате и индексы BRIN или B-tree по `timestamptz`.
- Для расчёта бизнес-дней воспользуйтесь расширением `business`, пользовательскими календарями.

## 5. Структурированные и полу-структурированные данные
- `json` vs `jsonb`: `jsonb` эффективен для поиска (`GIN` индекс, операции `@>`, `?`, `?|`, `?&`), поддерживает `jsonpath` (`@?`, `@@`).
- `array` — хранение списков; используйте функции `unnest()`, `array_agg()`, `array_position()` для работы.
- `hstore` — key/value словарь, компактен для десятков атрибутов.
- Композитные типы (`CREATE TYPE ... AS`) используются в функциях, возвращающих сложные структуры, и в таблицах.
- `record` и `ROW(...)` — динамические записи для временных результатов.

**Советы**:
- Не злоупотребляйте `jsonb` для часто обновляемых структур: перепаковка документа дороже, чем обновление отдельных столбцов.
- Для полнотекстового поиска по JSON используйте выражения `to_tsvector('simple', jsonb_extract_path_text(...))` и функциональные индексы.

## 6. Специализированные типы
- **Идентификаторы**: `uuid`, `ulid` (через расширения), `snowflake`-подобные генераторы.
- **Сетевые**: `inet`, `cidr`, `macaddr`, `macaddr8` — поддерживают операции принадлежности подсети, сортировки.
- **Геометрия**: `point`, `line`, `lseg`, `box`, `path`, `polygon`, `circle`; для продвинутой геометрии используйте PostGIS (`geometry`, `geography`).
- **Диапазоны**: `int4range`, `numrange`, `daterange`, `tsrange`, `tstzrange`; поддерживают включение/пересечение, функции `lower()`, `upper()`, `isempty()`.
- **Перечисления (`ENUM`)**: фиксированный набор значений; изменяются через `ALTER TYPE ... ADD VALUE`.
- **Бинарные**: `bytea` — хранение файлов, хэшей, двоичных протоколов.

## 7. Типы для статистики и аналитики
- `decimal`/`numeric` с высокой точностью для финансовых отчётов.
- `interval`, `age()` для расчёта времени между событиями.
- `cube`, `earthdistance` (расширения) — многомерная аналитика и геодезические вычисления.
- `ltree` — иерархические данные (каталоги, пути).
- `hyperloglog`, `tdigest` — агрегатные типы из расширений для приблизительных вычислений.

## 8. Моделирование и схемы
- **Нормализация**: до 3НФ для OLTP, денормализация и агрегаты — для аналитики.
- **Партиционирование**: декларативное `PARTITION BY RANGE/LIST/HASH` для больших таблиц; тип партиционного ключа должен поддерживать сравнение и хеширование.
- **Наследование**: таблицы-наследники (`INHERITS`) для логической сегментации данных; полезно для многотенантных систем.
- **Домены**: создают типы с кастомными ограничениями, например `CREATE DOMAIN email AS text CHECK (...);`.
- **Генерация значений**: `DEFAULT`, `GENERATED ALWAYS AS`, `GENERATED ALWAYS AS IDENTITY`.

## 9. Работа с типами в приложениях
- **Драйверы**: используйте типизированные биндинги (`psycopg`, `pgx`, `pg` для Ruby) для предотвращения SQL-инъекций.
- **Сериализация**: при обмене JSON/Protobuf чётко определяйте соответствие типов, особенно для даты/времени.
- **Миграции**: при изменении типа используйте `USING` для преобразования (`ALTER TABLE ... ALTER COLUMN ... TYPE ... USING ...`).
- **Документация**: фиксируйте значение `COLLATE`, `CONSTRAINT` и домены в схемах, чтобы новые разработчики понимали ограничения.

Грамотный выбор типов данных упрощает поддержку, ускоряет запросы и уменьшает риск ошибок в бизнес-логике.
