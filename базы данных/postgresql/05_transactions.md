# Транзакции и конкурентный доступ в PostgreSQL


## Содержание

1. [1. Основы транзакций](#1-основы-транзакций)
2. [2. Уровни изоляции](#2-уровни-изоляции)
3. [3. Типичные аномалии и их предотвращение](#3-типичные-аномалии-и-их-предотвращение)
4. [4. Блокировки](#4-блокировки)
   - [4.1 Уровни блокировок](#41-уровни-блокировок)
   - [4.2 Диагностика блокировок](#42-диагностика-блокировок)
   - [4.3 Практические советы](#43-практические-советы)
5. [5. Управление конкурентным доступом](#5-управление-конкурентным-доступом)
6. [6. Двухфазные и распределённые транзакции](#6-двухфазные-и-распределённые-транзакции)
7. [7. Транзакции и WAL](#7-транзакции-и-wal)
8. [8. Взаимодействие с VACUUM](#8-взаимодействие-с-vacuum)
9. [9. Журналирование и наблюдение](#9-журналирование-и-наблюдение)

## 1. Основы транзакций
- Транзакция — атомарная последовательность операторов между `BEGIN` и `COMMIT`/`ROLLBACK`.
- Автокоммит выполняет каждый оператор как отдельную транзакцию; `BEGIN` отключает автокоммит и позволяет объединять несколько операторов.
- `SAVEPOINT` и `ROLLBACK TO SAVEPOINT` дают возможность частичного отката.
- `COMMIT AND CHAIN` завершает текущую транзакцию и немедленно запускает следующую с теми же параметрами изоляции.

## 2. Уровни изоляции
| Уровень | Грязное чтение | Неповторяющееся чтение | Фантомы | Особенности |
|---------|----------------|------------------------|---------|-------------|
| READ COMMITTED | ❌ | ✅ | ✅ | Каждое выражение видит состояние на начало выполнения. |
| REPEATABLE READ | ❌ | ❌ | ⚠️ (подавлены MVCC + predicate locks) | Снимок на момент `BEGIN`. |
| SERIALIZABLE | ❌ | ❌ | ❌ | SSI отслеживает опасные конфликты и может завершить транзакцию ошибкой `serialization_failure`. |
| READ UNCOMMITTED | ❌ | ✅ | ✅ | Синоним READ COMMITTED в PostgreSQL. |

**Рекомендации**:
- READ COMMITTED подходит для большинства OLTP-операций.
- REPEATABLE READ — для отчётов, когда важна стабильность набора данных.
- SERIALIZABLE — для финансовых операций, требующих строгой последовательности; закладывайте повтор попыток.

## 3. Типичные аномалии и их предотвращение
- **Lost Update**: две транзакции читают одну строку и обновляют её без блокировок. Решения: `SELECT ... FOR UPDATE`, сериализация на уровне приложения, SERIALIZABLE.
- **Non-Repeatable Read**: повторный SELECT возвращает разные данные. Решение: REPEATABLE READ, `SELECT ... FOR SHARE`.
- **Phantom Read**: набор строк меняется между запросами. Решение: SERIALIZABLE, блокировка диапазона `FOR SHARE`, `FOR KEY SHARE`.
- **Write Skew**: логический конфликт без прямого пересечения строк. PostgreSQL обнаруживает и откатывает транзакцию на SERIALIZABLE.

## 4. Блокировки
### 4.1 Уровни блокировок
- **Row-Level**: `FOR UPDATE`, `FOR NO KEY UPDATE`, `FOR SHARE`, `FOR KEY SHARE`, модифицируют `xmin/xmax` строк.
- **Table-Level**: `ACCESS SHARE`, `ROW SHARE`, `ROW EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE`, `ACCESS EXCLUSIVE`.
- **Advisory Locks**: `pg_advisory_lock`, `pg_try_advisory_lock`, `pg_advisory_xact_lock` — пользовательские блокировки на ключе `BIGINT` или паре `INT`.

### 4.2 Диагностика блокировок
- `pg_locks` показывает активные блокировки, типы, объекты и ожидания.
- `pg_stat_activity` (поля `wait_event_type`, `wait_event`) помогает определить, какие процессы ждут.
- `SELECT * FROM pg_blocking_pids(pid);` — идентификаторы процессов, которые блокируют текущий PID.
- Лог `log_lock_waits` + `deadlock_timeout` фиксируют длительные ожидания.

### 4.3 Практические советы
- Сортируйте обновления в одном порядке в разных приложениях, чтобы уменьшить риск дедлоков.
- Используйте `NOWAIT` или `SKIP LOCKED`, когда допустимо пропустить занятые строки (очереди задач).
- Ограничивайте длительность транзакций: избегайте ожидания пользовательского ввода внутри `BEGIN ... COMMIT`.
- Настройте `idle_in_transaction_session_timeout`, чтобы автоматически завершать забытые транзакции.

## 5. Управление конкурентным доступом
- Используйте оптимистичные стратегии (`SELECT ... FOR SHARE` + проверка версии) для операций чтение-проверка-запись.
- Обновляйте строки пакетами (`UPDATE ... WHERE id IN (...)`) вместо по одной, чтобы уменьшить overhead.
- Для очередей задач используйте `FOR UPDATE SKIP LOCKED` с `LIMIT`, чтобы распределять работу между воркерами.
- При массовых операциях применяйте `LOCK TABLE ... IN SHARE MODE` для стабильных снимков.

## 6. Двухфазные и распределённые транзакции
- `PREPARE TRANSACTION` → `COMMIT/ROLLBACK PREPARED` реализует двухфазный commit. Требуется настроить `max_prepared_transactions`.
- Незавершённые подготовленные транзакции удерживают блокировки, XID и ресурсы. Периодически проверяйте `pg_prepared_xacts`.
- Для интеграции с внешними системами используйте XA-драйверы или координацию на уровне приложения (outbox pattern, idempotent consumer).

## 7. Транзакции и WAL
- Каждая транзакция фиксируется в WAL: `wal_level`, `fsync`, `synchronous_commit` влияют на задержку фиксации.
- `commit_delay` и `commit_siblings` позволяют объединять fsync для групп транзакций.
- Большие транзакции генерируют много WAL; разбивайте операции на пачки и используйте `pg_switch_wal()` для контроля архивирования.

## 8. Взаимодействие с VACUUM
- `VACUUM` удаляет невидимые версии и обновляет карты видимости; длительные транзакции мешают `vacuum freeze` и могут вызвать wraparound.
- Следите за `age(datfrozenxid)` и настройте `autovacuum_freeze_max_age`, `vacuum_freeze_table_age`.
- Долгие read-only транзакции удерживают старые снимки и увеличивают объем `pg_wal` (реплики ждут replay). Планируйте отчёты так, чтобы они не блокировали автovacuum.

## 9. Журналирование и наблюдение
- Включите `log_statement = 'ddl'` и `log_duration` для аудита важных операций.
- Используйте `pg_stat_xact_user_tables`, `pg_stat_xact_user_functions` для статистики по текущей транзакции.
- Метрики блокировок доступны через `pg_locks`, `pg_stat_database_conflicts`, `pg_stat_replication` (конфликты на репликах).

Глубокое понимание уровней изоляции, блокировок и взаимодействия с WAL помогает строить надёжные и масштабируемые приложения на PostgreSQL.
