# Запросы, планы выполнения и статистика PostgreSQL

## 1. Классификация запросов
- **DDL** (`CREATE`, `ALTER`, `DROP`, `TRUNCATE`) — изменяют схему; могут требовать эксклюзивных блокировок.
- **DML** (`INSERT`, `UPDATE`, `DELETE`, `MERGE`) — модифицируют данные, создавая новые версии строк; влияют на MVCC.
- **DQL** (`SELECT`) — чтение данных, поддерживает CTE, оконные функции, рекурсивные запросы.
- **DCL** (`GRANT`, `REVOKE`, `ALTER ROLE`) — управление доступом и безопасностью.
- **TCL** (`BEGIN`, `COMMIT`, `ROLLBACK`, `SAVEPOINT`, `SET TRANSACTION`) — управление транзакциями и их параметрами.

## 2. Стратегия написания запросов
- Проектируйте схемы с учётом целевых запросов: определите типичные фильтры, соединения, частоту обновлений.
- Выбирайте только нужные столбцы (`SELECT` без `*` снижает передачу и ускоряет планы).
- Используйте явные `JOIN` вместо устаревших синтаксисов; следите за условиями соединений, чтобы избегать декартовых произведений.
- Разбивайте тяжёлые отчёты на CTE или временные таблицы, если это упрощает понимание и переиспользование промежуточных результатов.
- Для пагинации больших наборов данных рассматривайте `keyset pagination` (`WHERE id > ? ORDER BY id LIMIT 50`).
- Применяйте оконные функции (`ROW_NUMBER`, `SUM() OVER`) для ранжирования и агрегатов вместо подзапросов.

## 3. Инструменты анализа и мониторинга
- `EXPLAIN` — оценивает план без выполнения; `EXPLAIN ANALYZE` запускает запрос и показывает фактическое время/строки.
- Опции `BUFFERS`, `TIMING`, `ANALYZE`, `COSTS`, `VERBOSE`, `FORMAT JSON/YAML/XML` дают дополнительную информацию.
- `pg_stat_activity` — мониторинг активных сеансов (поля `state`, `wait_event`, `query`, `backend_xid`).
- `pg_stat_statements` — агрегированные показатели: среднее время, количество вызовов, дисперсия, IO.
- `pg_stat_progress_*` — прогресс долгих операций (`vacuum`, `analyze`, `create index`).
- Логирование: `log_min_duration_statement`, `log_statement`, `auto_explain` (расширение) для планов медленных запросов.

## 4. Чтение планов выполнения
1. **Корневой узел**: определяет тип верхней операции (`Aggregate`, `Nested Loop`, `Gather`).
2. **Сравнение оценок и фактических значений**: `cost`, `rows`, `width` vs. `actual time`, `actual rows`. Расхождения указывают на неточную статистику или неподходящий план.
3. **Типы сканирования**:
   - `Seq Scan` — последовательное чтение, допустимо для небольших таблиц или низкой селективности.
   - `Index Scan` / `Index Only Scan` — использует индексы, обращайте внимание на `Index Cond`.
   - `Bitmap Heap Scan` — эффективно комбинирует несколько условий.
   - `Tid Scan` — выборка по TID, встречается при `ctid` или `LIMIT 1` по уникальному ключу.
4. **Соединения**:
   - `Nested Loop` — хорошо при маленьком внешнем наборе и индексах на внутренней таблице.
  - `Hash Join` — требует памяти (`work_mem`); следите за сообщением `Hash Cond` и `Hash Buckets`.
   - `Merge Join` — предполагает отсортированные входы; часто сопровождается `Sort` узлами.
5. **Параллелизм**: `Gather`, `Parallel Seq Scan`. Контролируется `max_parallel_workers_per_gather`, `parallel_leader_participation`.
6. **Дополнительные показатели**: `Rows Removed by Filter`, `Recheck Cond`, `Heap Fetches`, `Shared Blocks Hit/Read/Dirty`, `Temp Read/Write`.
7. **JIT**: при `jit=on` анализируйте секцию `JIT:` — она показывает время генерации кода и выполнение функций.

## 5. Работа со статистикой
- `ANALYZE` обновляет гистограммы и данные селективности; запускается автоматически `autovacuum` или вручную.
- `ALTER TABLE ... ALTER COLUMN ... SET STATISTICS` увеличивает глубину статистики для проблемных столбцов.
- Расширение `pg_stats_ext` позволяет создавать расширенную статистику (корреляции, многомерные гистограммы).
- Проверяйте `pg_stats` для анализа распределения значений, `correlation` помогает понять эффективность индексов.
- `VACUUM` поддерживает актуальность карт видимости и предотвращает рост таблиц.

## 6. Оптимизация запросов
- Перепишите коррелированные подзапросы в `JOIN`, если это уменьшает количество обращений.
- Используйте `EXISTS` вместо `IN` для подзапросов с большим числом значений.
- Для сложных агрегатов применяйте `GROUPING SETS`, `ROLLUP`, `CUBE` вместо множества отдельных запросов.
- Работайте с материализованными представлениями для тяжёлых отчётов (`REFRESH MATERIALIZED VIEW CONCURRENTLY`).
- Распределяйте нагрузку: `SET LOCAL work_mem`, `enable_seqscan`, `enable_hashjoin` для экспериментов (не для постоянной работы).
- При частых обновлениях счётчиков используйте `INSERT ... ON CONFLICT ... DO UPDATE`, `UPSERT` с учётом блокировок.

## 7. Сбор метрик и профилирование
- `pg_stat_database` — общее число транзакций, блоков чтения, время работы `backend`.
- `pg_statio_user_tables` и `pg_statio_all_indexes` — IO-профиль по таблицам/индексам.
- `pg_stat_user_functions` — статистика пользовательских функций.
- `pg_wait_sampling` (расширение) — семплирование ожиданий, полезно для анализа латентности.
- `pg_stat_kcache` — CPU/IO consumption по запросам.
- Интеграция с Prometheus, Grafana: сбор дашбордов по latency, throughput, блокировкам, размеру WAL.

## 8. Работа с временными файлами и памятью
- `log_temp_files` помогает обнаружить запросы, выходящие за пределы `work_mem`.
- В `EXPLAIN (ANALYZE)` смотрите `actual time` и `Peak Memory Usage` (в формате JSON).
- Учитывайте, что `work_mem` применяется для каждого узла, поэтому запрос с несколькими сортировками может потреблять много памяти.
- Используйте `temp_tablespaces` для разгрузки основного диска, если временные файлы велики.

## 9. Примеры типичных расследований
- **Медленная выборка**: проверяем план (`EXPLAIN ANALYZE`), селективность условий, наличие индекса, размер таблицы, IO статистику.
- **Рост временных файлов**: включаем `log_temp_files`, настраиваем `work_mem`, проверяем запросы с сортировками/хешами.
- **Неиспользуемый индекс**: анализируем `idx_scan`, количество `seq_scan`, рассматриваем перепроектирование запроса или удаление индекса.
- **Запросы с параллелизмом**: контролируем параметры `max_parallel_workers`, следим за `parallel_worker_number` в плане.

Тщательный анализ планов и статистики позволяет точечно оптимизировать запросы и поддерживать стабильную производительность системы.
