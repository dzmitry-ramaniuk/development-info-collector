# Основы и архитектура Apache ActiveMQ

## Содержание

1. [Что такое ActiveMQ](#что-такое-activemq)
2. [Основные концепции JMS](#основные-концепции-jms)
3. [Архитектура ActiveMQ](#архитектура-activemq)
4. [Модели обмена сообщениями](#модели-обмена-сообщениями)
5. [Протоколы и транспорты](#протоколы-и-транспорты)
6. [Персистентность и надёжность](#персистентность-и-надёжность)
7. [Пример использования](#пример-использования)
8. [Вопросы для самопроверки](#вопросы-для-самопроверки)

## Что такое ActiveMQ

Apache ActiveMQ — это высокопроизводительный брокер сообщений с открытым исходным кодом, написанный на Java и реализующий спецификацию JMS (Java Message Service). Он поддерживает множество протоколов и языков программирования.

### Историческая справка

- **2004 год** — начало разработки проекта
- **2007 год** — стал проектом Apache Top Level Project
- **ActiveMQ Classic** — оригинальная версия (JMS 1.1/2.0)
- **ActiveMQ Artemis** — следующее поколение (основан на HornetQ, более современная архитектура)

> **Важно**: В настоящее время Apache рекомендует использовать ActiveMQ Artemis для новых проектов, так как он предлагает лучшую производительность и масштабируемость. ActiveMQ Classic находится в режиме поддержки.

### Ключевые характеристики

- **Открытый исходный код**: Лицензия Apache 2.0
- **Кросс-платформенность**: Работает везде, где есть Java
- **Множество клиентов**: Java, C, C++, Python, .NET, Ruby, PHP
- **Гибкость**: Поддержка различных моделей обмена сообщениями
- **Надёжность**: Гарантии доставки, транзакции, персистентность

## Основные концепции JMS

### JMS (Java Message Service)

JMS — это стандартный API Java для обмена сообщениями между приложениями. Определяет:

- **Провайдер (Provider)**: Реализация JMS (ActiveMQ, RabbitMQ, IBM MQ и др.)
- **Клиент (Client)**: Приложение, отправляющее или получающее сообщения
- **Сообщение (Message)**: Объект данных, пересылаемый между клиентами
- **Очередь (Queue)**: Point-to-Point модель (один отправитель → один получатель)
- **Топик (Topic)**: Publish-Subscribe модель (один отправитель → много получателей)

### Структура сообщения JMS

```java
// Сообщение JMS состоит из трёх частей:
1. Header (заголовки)
   - JMSDestination: куда отправлено
   - JMSDeliveryMode: PERSISTENT или NON_PERSISTENT
   - JMSMessageID: уникальный идентификатор
   - JMSTimestamp: время создания
   - JMSExpiration: время истечения
   - JMSPriority: приоритет (0-9)
   - JMSReplyTo: адрес для ответа

2. Properties (свойства)
   - Пользовательские свойства (например, для фильтрации)
   - Стандартные JMS-свойства

3. Body (тело)
   - TextMessage: строка
   - BytesMessage: байтовый массив
   - MapMessage: пары ключ-значение
   - ObjectMessage: сериализованный Java объект
   - StreamMessage: поток примитивных типов
```

## Архитектура ActiveMQ

### Основные компоненты

```
┌─────────────────────────────────────────────────────────────┐
│                    ActiveMQ Broker                          │
├─────────────────────────────────────────────────────────────┤
│  ┌───────────────────┐  ┌───────────────────────────────┐  │
│  │   Transport       │  │    Message Store              │  │
│  │   Connectors      │  │    (KahaDB, JDBC, LevelDB)    │  │
│  │ (OpenWire, AMQP,  │  └───────────────────────────────┘  │
│  │  STOMP, MQTT)     │                                      │
│  └───────────────────┘  ┌───────────────────────────────┐  │
│           │             │    Destination Management      │  │
│           ▼             │    - Queues                    │  │
│  ┌───────────────────┐  │    - Topics                    │  │
│  │   Message Router  │  │    - Virtual Destinations      │  │
│  └───────────────────┘  └───────────────────────────────┘  │
│           │                                                  │
│           ▼             ┌───────────────────────────────┐  │
│  ┌───────────────────┐  │    Plugins & Interceptors     │  │
│  │   Dispatcher      │  │    - Security                  │  │
│  └───────────────────┘  │    - Statistics                │  │
│                         │    - Advisory Messages         │  │
│                         └───────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
         ▲                           │
         │                           ▼
    Producers                    Consumers
```

### Компоненты брокера

| Компонент | Описание |
|-----------|----------|
| **Transport Connector** | Принимает входящие соединения по различным протоколам |
| **Message Router** | Маршрутизирует сообщения к правильным destinations |
| **Dispatcher** | Доставляет сообщения подписчикам |
| **Message Store** | Хранит персистентные сообщения |
| **Destination** | Логическое место назначения (Queue или Topic) |
| **Plugin System** | Расширения для безопасности, мониторинга, логирования |

## Модели обмена сообщениями

### Point-to-Point (Queue)

```
Producer → [Queue] → Consumer
```

**Характеристики:**
- Одно сообщение обрабатывается только одним получателем
- Сообщения сохраняются до получения или истечения срока
- Поддерживается балансировка нагрузки между несколькими consumers
- Гарантирует порядок обработки (FIFO по умолчанию)

**Пример использования:**
```java
// Отправка сообщения в очередь
ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
Connection connection = factory.createConnection();
connection.start();

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
Queue queue = session.createQueue("orders.queue");
MessageProducer producer = session.createProducer(queue);

TextMessage message = session.createTextMessage("Order #12345");
producer.send(message);

producer.close();
session.close();
connection.close();
```

### Publish-Subscribe (Topic)

```
              ┌─→ Consumer 1
Producer → [Topic] ─┼─→ Consumer 2
              └─→ Consumer 3
```

**Характеристики:**
- Одно сообщение доставляется всем активным подписчикам
- Сообщения не сохраняются, если нет активных подписчиков (для неперсистентных)
- Durable subscriptions — сохраняют сообщения для офлайн-подписчиков
- Полезно для уведомлений и широковещательных сообщений

**Пример использования:**
```java
// Подписка на топик
ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
Connection connection = factory.createConnection();
connection.setClientID("client-1"); // Для durable subscription
connection.start();

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
Topic topic = session.createTopic("notifications.topic");

// Durable subscription - сохраняет сообщения для офлайн клиентов
MessageConsumer consumer = session.createDurableSubscriber(topic, "subscriber-1");

consumer.setMessageListener(message -> {
    if (message instanceof TextMessage) {
        try {
            System.out.println("Получено: " + ((TextMessage) message).getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
});

// Слушаем сообщения...
// consumer.close();
// session.close();
// connection.close();
```

### Virtual Destinations

ActiveMQ поддерживает **виртуальные destinations**, которые позволяют комбинировать модели:

**Virtual Topics** — комбинация Queue + Topic:
```
Producer → VirtualTopic.Orders → Consumer.A.VirtualTopic.Orders (Queue)
                               → Consumer.B.VirtualTopic.Orders (Queue)
```

Преимущества:
- Множественные подписчики, как в Topic
- Балансировка нагрузки внутри каждой группы, как в Queue
- Персистентность и надёжность

## Протоколы и транспорты

### Поддерживаемые протоколы

| Протокол | Описание | Порт по умолчанию |
|----------|----------|-------------------|
| **OpenWire** | Нативный бинарный протокол ActiveMQ (Java) | 61616 |
| **AMQP** | Advanced Message Queuing Protocol (кросс-платформенный) | 5672 |
| **STOMP** | Simple Text Oriented Messaging Protocol | 61613 |
| **MQTT** | Message Queuing Telemetry Transport (IoT) | 1883 |
| **WebSocket** | Для браузеров и веб-приложений | 61614 |
| **HTTP/HTTPS** | Через REST API | 8161 |

### Конфигурация транспортов

```xml
<!-- activemq.xml -->
<transportConnectors>
    <!-- OpenWire - нативный протокол -->
    <transportConnector name="openwire" uri="tcp://0.0.0.0:61616?maximumConnections=1000"/>
    
    <!-- AMQP для интероперабельности -->
    <transportConnector name="amqp" uri="amqp://0.0.0.0:5672"/>
    
    <!-- STOMP для легковесных клиентов -->
    <transportConnector name="stomp" uri="stomp://0.0.0.0:61613"/>
    
    <!-- MQTT для IoT устройств -->
    <transportConnector name="mqtt" uri="mqtt://0.0.0.0:1883"/>
    
    <!-- WebSocket для браузеров -->
    <transportConnector name="ws" uri="ws://0.0.0.0:61614"/>
</transportConnectors>
```

## Персистентность и надёжность

### Режимы доставки

**PERSISTENT (персистентные сообщения):**
- Сохраняются на диск перед отправкой acknowledgement
- Переживают перезапуск брокера
- Гарантируют доставку (at-least-once)
- Медленнее из-за записи на диск

**NON_PERSISTENT (неперсистентные сообщения):**
- Хранятся только в памяти
- Быстрее, но могут быть потеряны при сбое
- Подходят для сообщений, которые быстро устаревают

```java
// Установка режима доставки
producer.setDeliveryMode(DeliveryMode.PERSISTENT); // по умолчанию
// или
producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
```

### Хранилища сообщений

| Тип | Описание | Когда использовать |
|-----|----------|-------------------|
| **KahaDB** | Встроенное файловое хранилище (по умолчанию) | Общий случай, хорошая производительность |
| **JDBC** | Реляционная БД (MySQL, PostgreSQL, Oracle) | Когда нужна интеграция с существующей БД |
| **LevelDB** | Быстрое key-value хранилище | Высокая производительность, replicated setup |
| **Memory** | Только в памяти | Тестирование, неперсистентные сообщения |

### Транзакции

ActiveMQ поддерживает локальные JMS транзакции и XA (distributed) транзакции:

```java
// Локальная транзакция
Session session = connection.createSession(true, Session.SESSION_TRANSACTED);

try {
    MessageProducer producer = session.createProducer(queue);
    TextMessage msg1 = session.createTextMessage("Message 1");
    TextMessage msg2 = session.createTextMessage("Message 2");
    
    producer.send(msg1);
    producer.send(msg2);
    
    session.commit(); // Оба сообщения отправлены атомарно
} catch (Exception e) {
    session.rollback(); // Откат обоих сообщений
}
```

### Acknowledgement modes

| Режим | Описание |
|-------|----------|
| **AUTO_ACKNOWLEDGE** | Автоматическое подтверждение после успешного return из onMessage() |
| **CLIENT_ACKNOWLEDGE** | Клиент вручную вызывает message.acknowledge() |
| **DUPS_OK_ACKNOWLEDGE** | Ленивое подтверждение, возможны дубликаты, но быстрее |
| **SESSION_TRANSACTED** | Подтверждение через session.commit() |

## Пример использования

### Полный пример Producer

```java
import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;

public class OrderProducer {
    public static void main(String[] args) throws JMSException {
        // 1. Создаём фабрику соединений
        ConnectionFactory factory = new ActiveMQConnectionFactory(
            "tcp://localhost:61616"
        );
        
        // 2. Создаём соединение
        Connection connection = factory.createConnection();
        connection.start();
        
        // 3. Создаём сессию (не транзакционная, auto-acknowledge)
        Session session = connection.createSession(
            false, 
            Session.AUTO_ACKNOWLEDGE
        );
        
        // 4. Создаём destination (очередь)
        Queue queue = session.createQueue("orders.queue");
        
        // 5. Создаём producer
        MessageProducer producer = session.createProducer(queue);
        producer.setDeliveryMode(DeliveryMode.PERSISTENT);
        
        // 6. Создаём и отправляем сообщение
        TextMessage message = session.createTextMessage();
        message.setText("{\"orderId\": 12345, \"amount\": 99.99}");
        message.setStringProperty("priority", "high");
        
        producer.send(message);
        System.out.println("Отправлено: " + message.getText());
        
        // 7. Закрываем ресурсы
        producer.close();
        session.close();
        connection.close();
    }
}
```

### Полный пример Consumer

```java
import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;

public class OrderConsumer {
    public static void main(String[] args) throws JMSException, InterruptedException {
        // 1. Создаём фабрику и соединение
        ConnectionFactory factory = new ActiveMQConnectionFactory(
            "tcp://localhost:61616"
        );
        Connection connection = factory.createConnection();
        connection.start();
        
        // 2. Создаём сессию
        Session session = connection.createSession(
            false, 
            Session.AUTO_ACKNOWLEDGE
        );
        
        // 3. Создаём destination
        Queue queue = session.createQueue("orders.queue");
        
        // 4. Создаём consumer
        MessageConsumer consumer = session.createConsumer(queue);
        
        // 5. Устанавливаем listener (асинхронная обработка)
        consumer.setMessageListener(new MessageListener() {
            @Override
            public void onMessage(Message message) {
                try {
                    if (message instanceof TextMessage) {
                        TextMessage textMessage = (TextMessage) message;
                        System.out.println("Получено: " + textMessage.getText());
                        System.out.println("Priority: " + 
                            message.getStringProperty("priority"));
                    }
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        });
        
        // 6. Ждём сообщения
        System.out.println("Ожидание сообщений...");
        Thread.sleep(10000); // Слушаем 10 секунд
        
        // 7. Закрываем ресурсы
        consumer.close();
        session.close();
        connection.close();
    }
}
```

### Конфигурация через Spring

```xml
<!-- Spring context.xml -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Фабрика соединений -->
    <bean id="connectionFactory" 
          class="org.apache.activemq.ActiveMQConnectionFactory">
        <property name="brokerURL" value="tcp://localhost:61616"/>
    </bean>

    <!-- JMS Template для упрощённой работы -->
    <bean id="jmsTemplate" 
          class="org.springframework.jms.core.JmsTemplate">
        <property name="connectionFactory" ref="connectionFactory"/>
        <property name="defaultDestinationName" value="orders.queue"/>
    </bean>

    <!-- Message Listener Container -->
    <bean id="messageListenerContainer" 
          class="org.springframework.jms.listener.DefaultMessageListenerContainer">
        <property name="connectionFactory" ref="connectionFactory"/>
        <property name="destinationName" value="orders.queue"/>
        <property name="messageListener" ref="orderMessageListener"/>
    </bean>
</beans>
```

## Вопросы для самопроверки

### Базовые вопросы

1. **В чём разница между Queue и Topic в ActiveMQ?**
   - Queue: Point-to-Point, одно сообщение → один получатель
   - Topic: Publish-Subscribe, одно сообщение → все активные подписчики
   - Queue поддерживает load balancing между consumers
   - Topic поддерживает durable subscriptions для офлайн-подписчиков

2. **Что такое JMS и какую роль играет ActiveMQ?**
   - JMS — стандартный Java API для обмена сообщениями
   - ActiveMQ — это JMS Provider (реализация спецификации JMS)
   - Позволяет писать переносимый код, не привязанный к конкретному брокеру

3. **Какие протоколы поддерживает ActiveMQ?**
   - OpenWire (нативный), AMQP, STOMP, MQTT, WebSocket, HTTP/HTTPS
   - Каждый протокол оптимизирован для разных сценариев и клиентов

4. **В чём разница между PERSISTENT и NON_PERSISTENT сообщениями?**
   - PERSISTENT: сохраняются на диск, переживают перезапуск, медленнее
   - NON_PERSISTENT: только в памяти, быстрее, но могут быть потеряны

### Продвинутые вопросы

5. **Что такое Virtual Topics и когда их использовать?**
   - Комбинация преимуществ Queue и Topic
   - Позволяют множественным consumer groups подписываться на топик
   - Каждая группа получает свою копию сообщений с load balancing

6. **Какие режимы acknowledgement поддерживает JMS?**
   - AUTO_ACKNOWLEDGE: автоматически после onMessage()
   - CLIENT_ACKNOWLEDGE: вручную через message.acknowledge()
   - DUPS_OK_ACKNOWLEDGE: ленивое, возможны дубликаты
   - SESSION_TRANSACTED: через commit/rollback транзакции

7. **Какие хранилища сообщений поддерживает ActiveMQ?**
   - KahaDB (по умолчанию): файловое хранилище
   - JDBC: реляционные БД
   - LevelDB: key-value хранилище
   - Memory: только в памяти (для тестов)

8. **Как обеспечить exactly-once доставку в ActiveMQ?**
   - Использовать транзакции (локальные JMS или XA)
   - CLIENT_ACKNOWLEDGE mode с идемпотентной обработкой
   - Комбинация PERSISTENT mode + transacted session + дедупликация на стороне получателя

### Практические вопросы

9. **Что произойдёт, если consumer долго обрабатывает сообщение?**
   - Зависит от prefetch limit и consumer timeout
   - Другие consumers могут забрать следующие сообщения (load balancing)
   - При превышении timeout сообщение может быть redelivered

10. **Как настроить priority для сообщений?**
    ```java
    producer.setPriority(9); // 0-4 нормальный, 5-9 высокий
    message.setJMSPriority(9);
    ```
    - Требует включения priorityMessages на destination
    - Сообщения с высоким приоритетом обрабатываются первыми

11. **Что такое Dead Letter Queue (DLQ)?**
    - Специальная очередь для сообщений, которые не удалось обработать
    - После N попыток redelivery сообщение перемещается в DLQ
    - Позволяет анализировать проблемные сообщения без блокировки основной очереди

12. **Как настроить Message TTL (Time To Live)?**
    ```java
    producer.setTimeToLive(60000); // 60 секунд в миллисекундах
    ```
    - Сообщения автоматически удаляются после истечения срока
    - Полезно для временно актуальных данных (например, котировки)

---

**Дополнительные ресурсы:**
- [Apache ActiveMQ Classic Documentation](https://activemq.apache.org/components/classic/)
- [Apache ActiveMQ Artemis Documentation](https://activemq.apache.org/components/artemis/)
- [Java Message Service (JMS) Tutorial](https://docs.oracle.com/javaee/7/tutorial/jms-concepts.htm)
