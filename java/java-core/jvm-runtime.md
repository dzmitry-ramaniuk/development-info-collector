# Виртуальная машина и платформа Java

## Экосистема JDK, JRE и JVM
Java Virtual Machine — это абстрактная вычислительная машина, которая исполняет байт-код и обеспечивает переносимость Java-программ. Пакет JRE включает JVM и стандартную библиотеку: его достаточно, чтобы запускать готовые приложения. Набор JDK дополняет JRE инструментами разработчика — компилятором `javac`, упаковщиками `jar`, `jlink`, отладчиками `jdb`, профилировщиками и прочими утилитами. Современные поставки JDK (OpenJDK, Temurin, Oracle JDK) публикуют обновления каждые квартал-полгода, и важно отслеживать изменения лицензий и сроков поддержки LTS-версий.

## Жизненный цикл Java-программы
1. **Компиляция**: исходный код `.java` компилируется в байт-код `.class`. Компилятор применяет оптимизации уровня языка (удаление мёртвого кода, разворачивание `switch` в таблицы).  
2. **Загрузка классов**: bootstrap-загрузчик поднимает базовые классы из `rt.jar`/модулей, затем работают platform и application class loader. Начиная с Java 9 модульная система JPMS формирует граф зависимостей модулей, а классы могут подгружаться лениво.  
3. **Верификация**: байт-код проверяется на корректность типов и безопасное использование стека.  
4. **Исполнение**: интерпретатор выполняет байт-код, а JIT-компилятор (C1/C2, Graal) горячие участки переводит в машинный код, применяя инлайнинг, escape-анализ и устранение виртуальных вызовов.  
5. **Мониторинг**: во время исполнения доступен сбор диагностических данных через `JMX`, `Java Flight Recorder`, события JVMTI.

## Архитектура JVM
JVM делит память на несколько областей: heap для объектов, stack для фреймов вызовов, metaspace для описаний классов, code cache для скомпилированного JIT-кода. Профиль нагрузки определяет настройки — размер кучи, использование `CompressedOops`, включение предварительного подогрева `TieredCompilation`. Класс-лоадеры формируют иерархию делегирования, что позволяет изолировать плагины и модульные приложения. На уровне байт-кода операции работают со стековой машиной, что упрощает портирование между архитектурами.

## Инструменты и диагностика
- `javap` для дизассемблирования байт-кода и изучения JIT-оптимизаций.  
- `jlink` и `jpackage` для создания минимальных рантаймов.  
- JDK Mission Control и Flight Recorder для анализа профиля выполнения, сборки мусора, блокировок.  
- JVMTI-агенты (например, профилировщики async-profiler, YourKit) помогают исследовать горячие участки и проблемы с памятью.  
- Опции запуска JVM (`-Xms`, `-Xmx`, `-XX:+UseG1GC`, `-XX:+PrintCompilation`) позволяют управлять производительностью и диагностикой.

## Вопросы на собеседовании
1. **Чем отличается JDK от JRE и когда нужно устанавливать каждую из поставок?**  
   *Ответ:* JRE включает только JVM и стандартные библиотеки — его достаточно, если нужно запускать готовый софт. JDK добавляет инструменты разработки: компилятор, отладчики, генераторы документации. Для разработки и сборки приложений требуется JDK, для развёртывания иногда достаточно JRE или собственноручно собранного рантайма через `jlink`.
2. **Как работает механизм загрузчиков классов и зачем он нужен?**  
   *Ответ:* Класс-лоадеры образуют иерархию делегирования: при загрузке класса запрос передаётся родителю, а при неудаче происходит собственная загрузка (например, из JAR). Это обеспечивает безопасность (базовые классы может загружать только bootstrap), даёт возможность изоляции плагинов и горячей перезагрузки модулей.
3. **Что такое JIT-компиляция и как она взаимодействует с интерпретатором?**  
   *Ответ:* Интерпретатор выполняет байт-код, а когда метод становится «горячим», профилировщик JVM передаёт его JIT-компилятору (C1, C2 или Graal). JIT переводит байт-код в оптимизированный машинный код, применяя инлайнинг, удаление проверок и оптимизации на основе профиля. JVM по-прежнему может откатываться к интерпретации при неверных предположениях (deoptimization).
4. **Какие инструменты есть у JVM для диагностики производительности?**  
   *Ответ:* Встроенные утилиты JDK (`jcmd`, `jmap`, `jstack`, `jfr`) позволяют получить дампы памяти, потоков, событий GC. Java Flight Recorder и Mission Control дают визуализацию профиля, а JVMTI-агенты типа async-profiler позволяют снимать CPU/alloc профили без большой нагрузки.
5. **Что происходит при запуске команды `java Main`?**  
   *Ответ:* Запускается JVM, инициализируется модульная система, application class loader ищет класс `Main`, выполняет статические инициализаторы, затем вызывается метод `public static void main(String[] args)`. Во время исполнения JIT компилирует горячие методы, сборщик мусора управляет памятью, а завершение программы инициирует финализацию и освобождение ресурсов операционной системой.
