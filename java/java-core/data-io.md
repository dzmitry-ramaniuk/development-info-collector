# Работа с данными и ввод/вывод

## Классический I/O
Пакет `java.io` предоставляет потоковую модель работы с байтами (`InputStream`, `OutputStream`) и символами (`Reader`, `Writer`). Буферизация (`BufferedInputStream`, `BufferedReader`) уменьшает количество системных вызовов. Фильтрующие потоки (`DataInputStream`, `ObjectOutputStream`) добавляют функциональность: чтение примитивов, сериализация объектов. Следите за кодировками: для текстовых данных используйте конструкторы с `Charset`, чтобы избежать проблем с локалью. Важное правило — закрывать потоки в `try-with-resources`, чтобы не утекали дескрипторы файлов.

## NIO и NIO.2
`java.nio` вводит буферы (`ByteBuffer`), каналы (`FileChannel`, `SocketChannel`) и неблокирующую модель через селекторы. Это позволяет строить высокопроизводительные серверы, обрабатывающие тысячи соединений одним потоком. NIO.2 (`java.nio.file`) добавляет API для работы с файлами и путями (`Path`, `Files`, `FileVisitor`), поддерживает асинхронные операции (`AsynchronousFileChannel`) и систему вотчеров (`WatchService`) для отслеживания изменений в файловой системе. Методы `Files.readString`, `writeString`, `lines` упрощают повседневные задачи чтения.

## Сериализация и форматы данных
Стандартная сериализация (`Serializable`) записывает граф объектов вместе с метаданными класса. Она удобна, но имеет недостатки: хрупкость при изменении версии класса, проблемы безопасности и производительности. Альтернативы — JSON (Jackson, Gson), бинарные форматы (Protocol Buffers, Avro), `record` в связке с библиотеками сериализации. Для совместимости с legacy-кодом применяют `serialVersionUID` и настраиваемые методы `writeObject`/`readObject`. При работе с внешними API важно валидировать входные данные и избегать десериализации непроверенных потоков.

## Работа с датами и временем
Современный пакет `java.time` предоставляет неизменяемые типы (`LocalDate`, `LocalDateTime`, `Instant`, `Duration`). Они безопасны в многопоточных приложениях и решают проблемы устаревших `Date`/`Calendar`. Используйте `ZoneId` и `ZonedDateTime` для расчётов с часовыми поясами, а `DateTimeFormatter` — для форматирования и парсинга. Таймеры и планировщики (`ScheduledExecutorService`) помогают выполнять задачи по расписанию, учитывая переходы на летнее время.

## Работа с файлами и ресурсами
Методы `Files.walk` и `Files.find` позволяют обходить каталоги, а `try-with-resources` гарантирует закрытие потоков. Для временных файлов используйте `Files.createTempFile`. Чтение конфигураций реализуется через `Properties`, YAML/JSON парсеры. Чтобы избежать утечек ресурсов, комбинируйте автоматическое закрытие с паттерном `try`-`finally` для сторонних библиотек, которые не поддерживают `AutoCloseable`.

## Вопросы на собеседовании
1. **Когда стоит выбирать NIO вместо классических потоков?**  
   *Ответ:* Когда нужно обрабатывать множество соединений или файлов без выделения отдельного потока на каждое. Каналы и селекторы позволяют multiplex-обработку, уменьшая расход памяти и контекстных переключений.
2. **Какие риски связаны со стандартной сериализацией Java?**  
   *Ответ:* Она создаёт плотную связку с версией класса, медленно работает из-за отражения, создаёт большие полезные нагрузки и уязвима для атак через подмену потоков. Рекомендуется использовать альтернативные форматы или настраивать `serialVersionUID` и whitelisting классов.
3. **Как корректно читать текстовый файл в определённой кодировке?**  
   *Ответ:* Использовать `Files.newBufferedReader(path, charset)` или `InputStreamReader` с явным `Charset`. Это гарантирует правильное декодирование символов и исключает зависимость от системной кодировки.
4. **Как безопасно работать с датами в разных часовых поясах?**  
   *Ответ:* Хранить время в UTC (`Instant`), а при отображении переводить в локальную зону через `ZonedDateTime`. Для пользовательского ввода указывать часовой пояс, избегать `Date`/`Calendar`, использовать `DateTimeFormatter` с явной локалью.
5. **Зачем нужен `try-with-resources` при работе с I/O?**  
   *Ответ:* Он гарантирует освобождение ресурсов (файловые дескрипторы, сокеты) даже при исключениях. Закрытие выполняется автоматически и корректно обрабатывает подавленные исключения, что уменьшает риск утечек и дублирования кода.
