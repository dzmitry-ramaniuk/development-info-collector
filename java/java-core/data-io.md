# Работа с данными и ввод/вывод

## Эволюция I/O API
- **`java.io`** — потоковая модель (InputStream/OutputStream, Reader/Writer), блокирующий ввод-вывод.
- **NIO (New I/O)** — буферно-ориентированный подход, каналы (`FileChannel`, `SocketChannel`), селекторы для неблокирующей работы.
- **NIO.2 (Java 7+)** — пакет `java.nio.file`, поддержка работы с файловой системой, символьными ссылками, атрибутами файлов.
- **Асинхронный I/O** — `AsynchronousFileChannel`, `AsynchronousSocketChannel`, позволяющие выполнять операции без блокировки
  потоков.

## Работа с файлами
Используйте `Paths.get` и `Files` для операций: чтение (`Files.readAllLines`, `Files.lines`), запись (`Files.write`), копирование
(`Files.copy`), управление атрибутами (`Files.getAttribute`). Следите за кодировкой: задавайте `Charset` явно. Для обхода дерева
применяйте `Files.walkFileTree` и реализуйте `SimpleFileVisitor`.

## Буферы и каналы
- **Buffer**: содержит позицию (`position`), лимит (`limit`), ёмкость (`capacity`). После записи вызывайте `flip`, после чтения —
  `clear` или `compact`.
- **Channel**: двунаправленный канал передачи данных. `FileChannel` поддерживает `transferTo/transferFrom` (zero-copy), `map`
  (memory-mapped files).
- **Selector**: мультиплексирует операции над каналами. Используйте `SelectionKey` и регистрируйте интересующие события
  (`OP_READ`, `OP_WRITE`).

## Работа с данными
- **Сериализация**: стандартный механизм (`Serializable`) сохраняет граф объектов. Контролируйте `serialVersionUID`, избегайте
  сериализации больших графов. Рассмотрите альтернативы: JSON (Jackson), Protobuf, Avro.
- **JSON/XML**: используйте популярные библиотеки (Jackson, Gson, JAXB). Настраивайте ObjectMapper, включайте валидацию схемы.
- **Дата и время**: пакет `java.time` (Java 8+) предлагает неизменяемые типы `LocalDate`, `ZonedDateTime`, `Duration`.

## Работа с сетевыми данными
- **HTTP**: `HttpClient` (Java 11) поддерживает синхронные и асинхронные запросы, HTTP/2, WebSocket.
- **Sockets**: `ServerSocket`, `Socket` для блокирующих сценариев; `SocketChannel` — неблокирующий.
- **gRPC/REST**: используйте DTO, валидацию (`javax.validation`) и логирование запросов.

## Производительность и безопасность
- Используйте `BufferedInputStream`/`BufferedOutputStream` для уменьшения количества системных вызовов.
- Для чтения больших файлов применяйте memory-mapped файлы (`FileChannel.map`).
- Следите за закрытием ресурсов: применяйте `try-with-resources`.
- При работе с внешними данными проверяйте размер и формат, чтобы избежать DoS и инъекций.
- Для шифрования используйте `CipherInputStream`, `CipherOutputStream` и безопасно храните ключи.

## Практические упражнения
1. Реализуйте утилиту копирования файлов с использованием NIO `Files.copy`, измерьте производительность против потоков `java.io`.
2. Напишите неблокирующий echo-сервер на `Selector`, обработайте несколько одновременных клиентов.
3. Создайте приложение, которое сериализует объекты в JSON (Jackson) и сохраняет их в файл, реализуйте валидацию схемы.

## Вопросы на собеседовании
1. **Чем отличается потоковая модель `java.io` от буферной `java.nio`?**
   *Ответ:* `java.io` читает/пишет байты по одному и блокирует поток, тогда как `java.nio` оперирует буферами, поддерживает
   неблокирующий ввод-вывод и позволяет использовать селекторы для масштабирования.
2. **Что такое memory-mapped файлы и когда их использовать?**
   *Ответ:* Это отображение файла в память процесса через `FileChannel.map`. Позволяет работать с файлами как с массивом байтов,
   снижает количество копирований. Полезно при обработке больших файлов и межпроцессном взаимодействии.
3. **Почему `ObjectOutputStream` не подходит для публичных API?**
   *Ответ:* Стандартная сериализация небезопасна: формат нестабилен, легко привести к атакам десериализации. Лучше использовать
   явные форматы (JSON, Protobuf) и валидировать входные данные.
4. **Как работать с датами и часовыми поясами?**
   *Ответ:* Использовать `java.time`: `Instant` для машинного времени, `ZonedDateTime` для времени с поясом, `DateTimeFormatter`
   для форматирования. Не храните `java.util.Date`/`Calendar`, переводите их в новые типы.
5. **Как реализовать асинхронный HTTP-запрос?**
   *Ответ:* Через `HttpClient.newHttpClient().sendAsync(request, BodyHandlers.ofString())`. Полученный `CompletableFuture`
   позволяет цеплять обработчики (`thenApply`, `exceptionally`).
