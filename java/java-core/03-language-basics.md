# Основы языка и синтаксис


## Содержание

1. [Типы данных и литералы](#типы-данных-и-литералы)
2. [Управляющие конструкции](#управляющие-конструкции)
3. [Классы, пакеты и модульность](#классы-пакеты-и-модульность)
4. [Работа со строками и форматированием](#работа-со-строками-и-форматированием)
5. [Ввод/вывод и взаимодействие с окружением](#вводвывод-и-взаимодействие-с-окружением)
6. [Best practices](#best-practices)
7. [Практические упражнения](#практические-упражнения)
8. [Вопросы на собеседовании](#вопросы-на-собеседовании)

## Типы данных и литералы
Java строго типизирована: каждый идентификатор имеет известный тип на этапе компиляции. Примитивы (`byte`, `short`, `int`,
`long`, `float`, `double`, `boolean`, `char`) хранятся в стеке и передаются по значению. Ссылочные типы (классы, интерфейсы,
массивы, перечисления) живут в куче и оперируют ссылками. Для работы с примитивами существуют обёртки (`Integer`, `Double`),
которые помогают интегрироваться с коллекциями и generics. Литералы поддерживают разделители `_`, суффиксы (`L`, `f`), числовые
системы (`0b`, `0x`), текстовые блоки (`"""`) и символы Unicode.

## Управляющие конструкции
- **Условия**: `if`, `switch` (включая `switch`-выражения с Java 14+). Новые `switch`-выражения позволяют возвращать значение и
  использовать `yield`.
- **Циклы**: `for`, enhanced `for`, `while`, `do-while`. Используйте `break`/`continue` с метками осторожно.
- **Исключения**: checked (`IOException`) и unchecked (`RuntimeException`). Обрабатывайте конкретные исключения, применяйте
  `try-with-resources` для управления ресурсами. Собственные исключения наследуйте от `RuntimeException`, если это ошибка логики.

## Классы, пакеты и модульность
Код организуется в пакеты (`package`) и модули (`module-info.java`). Модуль декларирует экспортируемые пакеты и требуемые
зависимости. Для инкапсуляции используйте уровни доступа: `private`, package-private (по умолчанию), `protected`, `public`.
Вложенные классы делятся на статические (не требуют экземпляра) и внутренние (имеют ссылку на внешний объект). Классы можно
помечать как `sealed`, ограничивая наследников.

## Работа со строками и форматированием
Строки неизменяемы, поэтому частая конкатенация в цикле неэффективна — используйте `StringBuilder` или `StringBuffer`.
Начиная с Java 15 появились текстовые блоки, облегчающие создание многострочных литералов. Для форматирования применяйте
`String.format`, `MessageFormat` или `Formatter`. Сравнивайте строки методом `equals`, учитывая локаль (`Collator`) и нормализацию.

## Ввод/вывод и взаимодействие с окружением
Базовые операции ввода/вывода реализованы через `java.io` и `java.nio`. Для чтения из консоли используйте `Scanner` или
`BufferedReader`. Файлы и директории управляются классами `Files`, `Paths` (NIO.2). Для работы с процессами применяйте
`ProcessBuilder`, а для взаимодействия с системными свойствами — `System.getProperty`.

## Best practices
- Соблюдайте `Effective Java`: минимизируйте изменяемость, используйте фабрики, отдавайте предпочтение композиции.
- Документируйте публичные API через Javadoc (`/** ... */`).
- Следите за предупреждениями компилятора и включайте `-Xlint`.
- Пишите юнит-тесты (JUnit, TestNG) и покрывайте ими ключевые классы.

## Практические упражнения
1. Реализуйте калькулятор командной строки, поддерживающий текстовые блоки для подсказок и `switch`-выражения.
2. Напишите класс с несколькими уровнями вложенности и проанализируйте байт-код, чтобы увидеть синтетические ссылки.
3. Создайте модульное приложение (`module-info.java`), экспортируйте API и запустите его через `java --module-path`.

## Вопросы на собеседовании
1. **Чем отличаются примитивные и ссылочные типы?**
   *Ответ:* Примитивы хранят значение напрямую и не допускают `null`. Ссылочные типы содержат адрес объекта, могут быть `null` и
   обрабатываются сборщиком мусора. Примитивы быстрее и занимают меньше памяти, но не работают с generics без автоупаковки.
2. **Когда использовать `switch`-выражение вместо классического `switch`?**
   *Ответ:* Когда нужно вернуть значение или сократить шаблонный код `break`. `switch`-выражения обрабатывают `enum`, `String`,
   поддерживают множественные метки и гарантируют исчерпывающий анализ при работе с `enum`.
3. **Что такое `try-with-resources` и как оно работает?**
   *Ответ:* Конструкция автоматически закрывает ресурсы, которые реализуют `AutoCloseable`. В байт-коде компилятор разворачивает
   блок в `try-finally`, обрабатывая подавленные исключения (`Throwable.addSuppressed`).
4. **Зачем нужны `sealed` классы?**
   *Ответ:* `sealed` ограничивает множество наследников, что облегчает контроль инвариантов и делает `switch` по `enum`-подобным
   иерархиям безопасным. Это упрощает анализ и генерацию pattern matching.
5. **Почему строки неизменяемы и к чему это приводит?**
   *Ответ:* Иммутабельность обеспечивает безопасность (пулы строк, использование в ClassLoader), упрощает кеширование и делает
   объекты потокобезопасными. Недостаток — необходимость дополнительных копий при модификации, поэтому используют `StringBuilder`.
