# Основы языка и синтаксис

## Типы данных и переменные
Java — статически типизированный язык. Примитивы (`byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`) хранят значения напрямую и располагаются на стеке или в объектах без дополнительных ссылок. Ссылочные типы (классы, массивы, интерфейсы) содержат указатель на объект в куче. Автоупаковка связывает примитивы с оболочками (`Integer`, `Long`) и позволяет использовать их в коллекциях, но порождает лишние аллокации и сравнения по ссылке. Константы объявляются через `final`, а ключевое слово `var` (с Java 10) разрешает вывод типов на уровне локальных переменных.

## Управление потоком и обработка исключений
Условные конструкции (`if`, `switch`) позволяют ветвить логику. Современный `switch` в форме выражения поддерживает стрелочную форму и возвращает значения. Циклы (`for`, `while`, `do-while`, enhanced for) удобны для итерации, а `Stream` и `Iterator` скрывают детали обхода коллекций. Механизм исключений реализует checked и unchecked исключения: первые должны быть объявлены или обработаны, вторые сигнализируют о программных ошибках. Конструкция `try-with-resources` автоматически закрывает ресурсы, реализующие `AutoCloseable`, и корректно обрабатывает подавленные исключения.

## Пакеты и модульность
Пакеты группируют классы по домену и формируют пространство имён. Использование `package` в начале файла задаёт принадлежность, а `import` облегчает доступ к типам. С Java 9 появилась модульная система JPMS, где `module-info.java` описывает зависимости (`requires`) и экспортируемые пакеты (`exports`). Модули улучшают инкапсуляцию, позволяют строить минимальные рантаймы через `jlink`, а также облегчают анализ зависимости и безопасность благодаря строгим границам доступа.

## Работа со строками
Строки являются неизменяемыми объектами, что позволяет кешировать их в строковом пуле и безопасно использовать в многопоточной среде. Начиная с Java 9 строки хранятся как массив `byte` + кодировка (Compact Strings). Построение сложных строк выполняется через `StringBuilder` или `StringBuffer` (потокобезопасный). Текстовые блоки (Java 15) упрощают работу с многострочными литералами, сохраняя форматирование. Методы `String` (`formatted`, `repeat`, `strip`) помогают строить пользовательские сообщения и очищать ввод.

## Вопросы на собеседовании
1. **Какая разница между примитивными и ссылочными типами?**  
   *Ответ:* Примитивы хранят значения напрямую и не могут быть `null`. Ссылочные типы хранят адрес объекта, могут ссылаться на `null`, требуют выделения памяти в куче и позволяют использовать методы. Автоупаковка создаёт объектную оболочку вокруг примитива, что увеличивает расходы по памяти и времени.
2. **Что такое checked и unchecked исключения?**  
   *Ответ:* Checked-исключения наследуются от `Exception` и должны быть объявлены в сигнатуре метода или обработаны. Unchecked-исключения (наследники `RuntimeException`) обозначают ошибки выполнения и могут не декларироваться. Выбор зависит от того, ожидает ли клиентский код восстановление.
3. **Как работает `try-with-resources` и почему он предпочтительнее `finally`?**  
   *Ответ:* В конструкции `try(Resource r = ...)` ресурс закрывается автоматически в блоке `try` после завершения, даже если выброшено исключение. Закрытие происходит в обратном порядке объявления ресурсов, а исключения из `close()` добавляются как подавленные, сохраняя информацию о первичной ошибке.
4. **Зачем нужна модульная система Java?**  
   *Ответ:* JPMS позволяет описать зависимости между модулями, ограничить видимость пакетов и собирать минимальные рантаймы. Это уменьшает поверхность атаки и ускоряет запуск, облегчая разработку монолитов и микросервисов с явными границами.
5. **Что произойдёт при сравнении строк через `==` и `equals()`?**  
   *Ответ:* `==` сравнивает ссылки и возвращает `true`, только если обе переменные указывают на один объект (например, из пула). Метод `equals()` сравнивает содержимое и корректно работает для разных экземпляров с одинаковым текстом. Поэтому для логического сравнения строк нужно использовать `equals()` или `equalsIgnoreCase()`.
