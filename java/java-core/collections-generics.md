# Коллекции и обобщения

## Архитектура коллекций
Фреймворк `java.util` делится на интерфейсы `Collection` и `Map`. `Collection` описывает последовательности элементов и имеет специализации `List`, `Set`, `Queue`. Реализации подбираются под паттерны доступа: `ArrayList` и `LinkedList` различаются стоимостью вставок и случайного доступа; `HashSet` и `TreeSet` — поддержкой порядка и сложности операций. Коллекции поддерживают fail-fast итераторы, которые выбрасывают `ConcurrentModificationException`, если коллекция изменяется без использования итератора.

## Выбор структуры данных
- **Списки**: `ArrayList` даёт O(1) доступ по индексу, но дороже вставки в середину; `LinkedList` хорош для частых вставок/удалений, но имеет низкую локальность памяти.  
- **Множества**: `HashSet` использует хэш-таблицу, `LinkedHashSet` сохраняет порядок вставки, `TreeSet` реализует красно-чёрное дерево и поддерживает диапазонные операции (`subSet`).  
- **Очереди**: `ArrayDeque` предоставляет стек/очередь без синхронизации; `PriorityQueue` реализует двоичную кучу для приоритетного доступа.  
- **Карты**: `HashMap` хранит данные в массиве бакетов, при высокой коллизии с Java 8 использует деревья; `LinkedHashMap` поддерживает LRU-поведение через `removeEldestEntry`; `ConcurrentHashMap` оптимизирует доступ из нескольких потоков.

## Обобщения и стирание типов
Generics позволяют описывать коллекции параметризованными типами и обеспечивают безопасность типов в compile-time. Из-за стирания типов (`type erasure`) информация о параметрах удаляется при компиляции: `List<String>` и `List<Integer>` становятся `List`. Это ограничивает создание массивов параметрических типов (`new T[]`), но даёт обратную совместимость с кодом до Java 5. Ограниченные параметры (`<T extends Number>`, `<? super T>`) контролируют допустимые типы и позволяют строить ковариантные/контрвариантные API.

## Неизменяемые и потокобезопасные коллекции
Методы `List.of`, `Map.ofEntries` создают неизменяемые коллекции, удобные для констант и конфигураций. Потокобезопасные варианты включают `Collections.synchronizedList`, `CopyOnWriteArrayList` (подходит для сценариев «много чтений — мало записей»), `ConcurrentSkipListMap` для отсортированных ассоциативных массивов. Важно понимать, что неизменяемость и потокобезопасность — разные свойства: неизменяемая коллекция автоматически потокобезопасна, но синхронизированные структуры могут менять состояние.

## Работа со Stream API
Коллекции интегрированы со Stream API: метод `stream()` создаёт ленивое представление последовательности, поддерживающее промежуточные (`map`, `filter`, `sorted`) и терминальные (`collect`, `reduce`) операции. Коллекторы (`Collectors.toList`, `groupingBy`, `partitioningBy`) позволяют трансформировать данные. Параллельные стримы (`parallelStream`) используют общий `ForkJoinPool`, но требуют осторожности: операции должны быть ассоциативными и не зависеть от порядка побочных эффектов.

## Вопросы на собеседовании
1. **Почему массивы ковариантны, а generics — нет?**  
   *Ответ:* Массивы проверяются на типы в runtime, поэтому `String[]` можно присвоить `Object[]`, но нарушение обнаружится через `ArrayStoreException`. Generics стираются в runtime, поэтому JVM не может обнаружить ошибку, если бы `List<String>` была подтипом `List<Object>`. Для безопасности типов generics инвариантны.
2. **Когда стоит выбирать `LinkedHashMap` вместо `HashMap`?**  
   *Ответ:* Когда важен предсказуемый порядок итерации (например, кэширование в порядке добавления или доступа). `LinkedHashMap` хранит двусвязный список элементов и позволяет реализовать LRU-кеш, переопределяя `removeEldestEntry`.
3. **Что такое wildcard `? extends` и `? super`?**  
   *Ответ:* `? extends T` разрешает читать значения как тип `T`, но запрещает добавлять новые элементы (кроме `null`). `? super T` позволяет добавлять объекты типа `T` или его подтипов, но чтение даёт `Object`. Это правило PECS (Producer Extends, Consumer Super).
4. **Чем `ConcurrentHashMap` лучше, чем `Collections.synchronizedMap`?**  
   *Ответ:* `ConcurrentHashMap` использует тонкие блокировки и неблокирующие операции (CAS), позволяя множеству потоков читать и обновлять разные сегменты без глобальной блокировки. `synchronizedMap` оборачивает всю карту одним монитором, что ограничивает параллелизм и увеличивает contention.
5. **Как создать неизменяемый список и чем он отличается от `Collections.unmodifiableList`?**  
   *Ответ:* `List.of(...)` возвращает истинно неизменяемый список без поддержки операций изменения. `Collections.unmodifiableList` создаёт обёртку, которая бросает исключение при изменении, но базовый список может быть изменён через исходную ссылку. Поэтому для полной неизменяемости используйте фабрики `List.of` или сторонние библиотеки (Guava ImmutableList).
