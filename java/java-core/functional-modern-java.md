# Функциональные возможности и современные фичи

## Lambda-выражения и функциональные интерфейсы
Lambda-выражения (Java 8) позволяют передавать поведение как данные: `(x, y) -> x + y`. Они реализуют функциональные интерфейсы — интерфейсы с единственным абстрактным методом (`@FunctionalInterface`). В стандартной библиотеке доступны `Function`, `Predicate`, `Supplier`, `Consumer`, `BiFunction` и др. Методы ссылок (`String::length`, `System.out::println`) делают код лаконичным. Использование lambda улучшает читаемость и позволяет строить декларативные API.

## Stream API
Stream представляет последовательность данных с поддержкой ленивых промежуточных и терминальных операций. Важные свойства: неизменяемость (стрим не хранит состояние исходной коллекции), ленивость (операции выполняются только при терминальном вызове), возможность параллельной обработки. Стандартные операции включают `map`, `filter`, `flatMap`, `sorted`, `distinct`, `reduce`, `collect`. Коллекторы (`Collectors.groupingBy`, `mapping`, `teeing`) помогают собирать агрегированные структуры. При параллельных стримах нужно следить за отсутствием гонок и избегать модификации внешнего состояния.

## Optional и обработка отсутствующих значений
`Optional` оборачивает значение, которое может отсутствовать. Методы `map`, `flatMap`, `filter`, `orElseGet`, `ifPresentOrElse` позволяют выразить цепочки обработки без `null`-проверок. `Optional` удобен в API, возвращающих результат операции или пустой контейнер. Его не рекомендуют использовать для полей сущностей или коллекций — лучше явно хранить пустой список. Важная практика — не сериализовать Optional и избегать `Optional` в параметрах методов, заменяя его перегрузками.

## Современные языковые улучшения
Java продолжает развиваться: 
- **var** для локального вывода типов (Java 10).  
- **Text Blocks** для многострочных строк (Java 15).  
- **Pattern Matching** для `instanceof` и `switch` (Java 16/17), упрощающее работу с иерархиями.  
- **Records** (Java 16) для неизменяемых DTO.  
- **Sealed классы** (Java 17) для контроля наследования.  
- **Switch Expressions** (Java 14) возвращают значения и требуют исчерпывающего перечисления вариантов.  
Следите за JEP, чтобы использовать новые возможности эффективно.

## Реактивные и асинхронные подходы
Помимо стандартного `CompletableFuture`, платформа предлагает реактивные API: `Flow` (Java 9) реализует спецификацию Reactive Streams с `Publisher`, `Subscriber`, `Processor`. Библиотеки Project Reactor, RxJava и Akka Streams строят поверх них декларативную обработку потоков данных с backpressure. Loom (в будущем выпуске) приносит виртуальные потоки и структуру `StructuredTaskScope`, упрощающие асинхронный код.

## Вопросы на собеседовании
1. **Когда использовать `map` и `flatMap` в Stream API?**  
   *Ответ:* `map` преобразует каждый элемент в новый, сохраняя структуру. `flatMap` разворачивает вложенные коллекции/Optional, объединяя элементы в одну последовательность. Используйте `flatMap`, когда источник содержит коллекции или необязательные значения.
2. **Что делает метод `orElseGet` у Optional?**  
   *Ответ:* Он принимает ленивый `Supplier`, который вызывается только если значение отсутствует. Это предотвращает лишние вычисления по сравнению с `orElse`, который вычисляет аргумент заранее.
3. **Чем `CompletableFuture` отличается от традиционных колбэков?**  
   *Ответ:* `CompletableFuture` предоставляет цепочку асинхронных операций с комбинируемыми стадиями (`thenApply`, `thenCompose`), поддерживает обработку исключений (`exceptionally`) и объединение результатов (`allOf`). Это даёт декларативный стиль вместо вложенных колбэков и упрощает обработку ошибок.
4. **Какие преимущества дают pattern matching для `instanceof`?**  
   *Ответ:* После проверки `if (obj instanceof String s)` можно сразу использовать переменную `s` без явного приведения, что делает код короче и безопаснее. В сочетании с `switch` pattern matching позволяет распаковывать записи и sealed-иерархии.
5. **Почему не стоит хранить `Optional` в полях сущностей?**  
   *Ответ:* Optional предназначен для возврата из методов. Хранение в полях усложняет сериализацию, порождает лишние объекты и запутывает модели данных. Лучше использовать `null` внутри сущности и возвращать наружу Optional через геттеры или предоставлять пустые коллекции.
