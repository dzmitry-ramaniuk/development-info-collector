# Коллекции и обобщения

## Каркас коллекций Java
Стандартный пакет `java.util` содержит интерфейсы `Collection`, `List`, `Set`, `Queue`, `Map`. Они определяют поведение,
которое реализуется конкретными структурами:
- **List**: `ArrayList` (динамический массив), `LinkedList` (двусвязный список), `CopyOnWriteArrayList` (для редких изменений).
- **Set**: `HashSet`, `LinkedHashSet`, `TreeSet`, `EnumSet`.
- **Queue/Deque**: `ArrayDeque`, `PriorityQueue`, `ConcurrentLinkedQueue`.
- **Map**: `HashMap`, `LinkedHashMap`, `TreeMap`, `ConcurrentHashMap`, `WeakHashMap`.

Выбор структуры зависит от операций: `ArrayList` хорош для случайного доступа, `LinkedList` — для частых вставок в середину,
`TreeSet`/`TreeMap` поддерживают упорядочивание, а `LinkedHashMap` — предсказуемый порядок обхода.

## Внутреннее устройство
- `ArrayList` хранит массив, увеличивая его по формуле `newCapacity = old + old/2`. Удаление из середины требует сдвига.
- `LinkedList` состоит из узлов `Node` с ссылками `prev`/`next`, позволяет добавлять элементы на концах за O(1).
- `HashMap` использует массив бакетов и цепочки (или деревья при большом количестве коллизий). Хэш-функция смешивает `hashCode`
  через `spread` (`(h ^ (h >>> 16))`).
- `ConcurrentHashMap` делит таблицу на сегменты (Java 7) или узлы с CAS (Java 8+), избегая глобальных блокировок.
- `TreeMap` реализует красно-чёрное дерево, обеспечивающее логарифмические операции и навигацию (`subMap`, `headMap`).

## Generics и типобезопасность
Generics появились в Java 5 и реализованы через стирание типов (type erasure). Во время компиляции создаётся специализированный
байт-код, но в рантайме все обобщённые типы приводятся к `Object`. Это позволяет поддерживать обратную совместимость, но влечёт
ограничения: нельзя создавать массивы обобщённых типов (`new T[]`), нельзя использовать примитивы без обёрток.

Используйте ограниченные параметры (`<T extends Comparable<T>>`), wildcard (`?`, `? extends`, `? super`) для ковариантности и
контравариантности. Соблюдайте правило PECS (Producer Extends, Consumer Super) при работе с коллекциями.

## Специализированные коллекции
- **Immutable Collections**: `List.of`, `Set.of`, `Map.of` — неизменяемые структуры. Библиотека Guava предлагает более гибкие
  неизменяемые коллекции.
- **EnumSet/EnumMap**: оптимизированы для перечислений, используют битовые наборы.
- **Deque**: `ArrayDeque` — быстрый двусторонний буфер для стеков и очередей.
- **Concurrent Collections**: `BlockingQueue` (`ArrayBlockingQueue`, `LinkedBlockingQueue`), `ConcurrentSkipListMap`.

## Best practices
- Выбирайте интерфейсы в сигнатурах (`List` вместо `ArrayList`).
- Используйте `Collections.unmodifiableList` или неизменяемые коллекции для защиты API.
- Не забывайте про `equals`/`hashCode` для ключей `Map` и элементов `Set`.
- Для крупных коллекций контролируйте initial capacity (`new HashMap<>(capacity, loadFactor)`).

## Практические упражнения
1. Реализуйте собственный `LRUCache` на основе `LinkedHashMap` и протестируйте его потокобезопасность.
2. Сравните время выполнения операций `get`/`put` для `HashMap`, `ConcurrentHashMap`, `TreeMap` при разных объёмах данных.
3. Напишите API, принимающий `List<? extends Number>`, и объясните, почему нельзя добавлять элементы в такую коллекцию.

## Вопросы на собеседовании
1. **Почему generics реализованы через стирание типов?**
   *Ответ:* Для сохранения совместимости со старым байт-кодом и JVM. Старые библиотеки, не использующие generics, продолжают
   работать без изменений, а компилятор обеспечивает проверку типов на этапе компиляции.
2. **Что такое правило PECS?**
   *Ответ:* Producer Extends, Consumer Super. Если коллекция предоставляет элементы (producer), используйте `? extends T`. Если
   коллекция принимает элементы (consumer), используйте `? super T`.
3. **Как `HashMap` справляется с коллизиями?**
   *Ответ:* Коллизии сначала формируют связный список. Если цепочка превышает порог (по умолчанию 8) и размер массива >= 64,
   структура превращается в красно-чёрное дерево, что уменьшает сложность операций до O(log n).
4. **Чем отличаются `HashMap` и `ConcurrentHashMap`?**
   *Ответ:* `ConcurrentHashMap` поддерживает одновременные операции без глобальной блокировки, деля таблицу на сегменты и
   используя CAS. Он запрещает `null` ключи/значения и предоставляет дополнительные атомарные операции (`computeIfAbsent`).
5. **Когда стоит предпочесть неизменяемые коллекции?**
   *Ответ:* Когда нужно обеспечить потокобезопасность и защиту от случайной модификации. Иммутабельные коллекции сокращают
   количество защитных копий и упрощают reasoning.
