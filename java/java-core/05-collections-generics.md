# Коллекции и обобщения


## Содержание

1. [Каркас коллекций Java](#каркас-коллекций-java)
   - [List](#list)
   - [Set](#set)
   - [Queue и Deque](#queue-и-deque)
   - [Map](#map)
2. [Контракты equals и hashCode](#контракты-equals-и-hashcode)
   - [Контракт equals](#контракт-equals)
   - [Контракт hashCode](#контракт-hashcode)
   - [Связь equals и hashCode в коллекциях](#связь-equals-и-hashcode-в-коллекциях)
   - [Правильная реализация](#правильная-реализация)
   - [Распространённые ошибки](#распространённые-ошибки)
3. [Generics и типобезопасность](#generics-и-типобезопасность)
4. [Специализированные коллекции](#специализированные-коллекции)
5. [Best practices](#best-practices)
6. [Практические упражнения](#практические-упражнения)
7. [Вопросы на собеседовании](#вопросы-на-собеседовании)

## Каркас коллекций Java
Стандартный пакет `java.util` задаёт каркас через интерфейсы `Collection`, `List`, `Set`, `Queue`, `Deque`, `Map`. Каждый
интерфейс описывает контракт по операциям, а конкретные структуры выбираются в зависимости от требуемых сложностей,
гарантий порядка и потокобезопасности.

### List
**List** обеспечивает упорядоченный набор элементов с доступом по индексу и поддержкой дубликатов.

- **`ArrayList`**. Хранит данные в динамическом массиве. При переполнении ёмкость увеличивается примерно на 50 %, копируя
  элементы в новый массив. Вставка и удаление из середины требуют сдвига элементов, но чтение по индексу выполняется за O(1).
  В многопоточном коде не потокобезопасен: требуется внешняя синхронизация (`Collections.synchronizedList`) или использование
  неизменяемой копии. Итератор fail-fast — при структурных изменениях в другом потоке он бросает `ConcurrentModificationException`.
- **`LinkedList`**. Построен на двусвязных узлах `Node` с полями `item`, `prev`, `next`. Добавление и удаление с концов
  выполняются за O(1), поиск по индексу — за O(n). В многопоточном окружении также требует синхронизации; кроме того,
  итерация небезопасна без внешних блокировок.
- **`CopyOnWriteArrayList`**. Для каждой структурной модификации создаёт новый массив. Чтения выполняются без блокировок и не
  видят незавершённых изменений. Подходит для сценариев «много чтений, мало записей». Итераторы не fail-fast: они работают с
  моментальным снимком. Записи дорогие по памяти и времени, поэтому в многопоточности подходит для конфигурационных списков,
  событийных слушателей и т.п.

### Set
**Set** хранит уникальные элементы без дубликатов. Гарантии по порядку зависят от реализации.

- **`HashSet`**. Реализован поверх `HashMap`, где элементы выступают ключами, а значением служит заглушка. Использует массив
  бакетов с цепочками или сбалансированными деревьями при длинных цепях. В многопоточности не потокобезопасен; необходимо
  внешнее блокирование. Fail-fast итераторы ведут себя аналогично `ArrayList`.
- **`LinkedHashSet`**. Сохраняет порядок вставки благодаря двусвязному списку поверх `HashSet`. Потокобезопасность аналогична
  `HashSet` — требуется внешняя синхронизация.
- **`TreeSet`**. Использует `NavigableMap` (по умолчанию `TreeMap`) с красно-чёрным деревом. Поддерживает сортированный порядок,
  операции навигации (`higher`, `lower`, `subSet`). Не потокобезопасен; при совместном доступе необходимы блокировки либо
  замена на `ConcurrentSkipListSet`.
- **`EnumSet`**. Внутренне — битовый набор (один или несколько `long`), поэтому операции выполняются очень быстро. Потокобезопасность
  не обеспечивается, но благодаря неизменяемости набора перечислений (фиксированное количество значений) легко создавать
  неизменяемые снапшоты и использовать `Collections.synchronizedSet` при необходимости.

### Queue и Deque
**Queue/Deque** предоставляют операции FIFO или двустороннего доступа.

- **`ArrayDeque`**. Кольцевой буфер на массиве. Поддерживает операции стека и очереди за O(1). Не блокирующая и
  непотокобезопасная: синхронизируйте при совместном доступе или используйте `ConcurrentLinkedDeque`.
- **`PriorityQueue`**. Реализует двоичную кучу (min-heap). Операции `offer`/`poll` выполняются за O(log n), доступ к минимальному
  элементу — O(1). Итератор не гарантирует порядок. Потокобезопасность отсутствует; для многопоточности используйте `PriorityBlockingQueue`
  или внешние блокировки.
- **`ConcurrentLinkedQueue`**. Неблокирующая очередь FIFO на связном списке с атомарными операциями (CAS). Поддерживает высокую
  конкуренцию без блокировок, но не подходит для структур, требующих ограниченной ёмкости. Итерации слабосогласованные — могут
  пропускать или повторять элементы, если очередь изменяется во время обхода.
- **`BlockingQueue`** (например, `ArrayBlockingQueue`, `LinkedBlockingQueue`). Предоставляют операции, ожидающие появления
  свободного места или элемента. Используют внутренние блокировки (`ReentrantLock`) и условные переменные. Потокобезопасны, но
  возможна конкуренция между производителями/потребителями; важно выбирать правильную ёмкость и стратегию обработки прерываний.

### Map
**Map** отображает ключи в значения, может поддерживать порядок или особенности хранения ссылок.

- **`HashMap`**. Массив бакетов с цепочками (`Node<K,V>`). При длинных цепочках (>=8) и достаточной ёмкости бакет превращается
  в красно-чёрное дерево. Рехеширование происходит при превышении `loadFactor`. Потокобезопасность отсутствует; конкурентный
  доступ может приводить к потерям данных. При необходимости используйте `Collections.synchronizedMap` или другие реализации.
- **`LinkedHashMap`**. Наследует `HashMap`, добавляя двусвязный список для порядка вставки или доступа (`accessOrder=true`). Часто
  применяется для LRU-кэшей. Потокобезопасность требует внешней синхронизации.
- **`TreeMap`**. Красно-чёрное дерево, реализующее `NavigableMap`. Обеспечивает отсортированные ключи и диапазонные операции.
  В многопоточности следует применять `Collections.synchronizedSortedMap` или `ConcurrentSkipListMap`.
- **`ConcurrentHashMap`**. В Java 8 использует массив бакетов с узлами и синхронизацию на уровне цепочек с помощью CAS и
  `synchronized` на отдельных бакетах при рехешировании. Обеспечивает неблокирующие чтения и ограниченную блокировку при записях.
  Итераторы слабосогласованные: отражают состояние на момент запуска и могут видеть некоторые последующие изменения. Поддерживает
  атомарные операции (`compute`, `merge`, `forEach`) с учётом многопоточности.
- **`WeakHashMap`**. Хранит ключи через `WeakReference`. Когда на ключ больше нет сильных ссылок, запись удаляется GC. Использует
  `ReferenceQueue` для очистки. Потокобезопасности нет; для многопоточности применяют внешнюю синхронизацию или `ConcurrentHashMap`
  с обёртками на слабых ссылках из сторонних библиотек.

## Контракты equals и hashCode

Методы `equals()` и `hashCode()` являются фундаментальными для работы с коллекциями на основе хеширования (`HashSet`, `HashMap`, 
`Hashtable`, `LinkedHashSet`, `LinkedHashMap`) и определяют, как объекты сравниваются и размещаются в этих структурах данных. 
Неправильная реализация этих методов приводит к непредсказуемому поведению коллекций: дубликаты в `Set`, невозможность найти 
объект в `Map`, утечки памяти и нарушение бизнес-логики.

### Контракт equals

Метод `equals(Object obj)` определён в классе `Object` и по умолчанию сравнивает ссылки (аналогично `==`). При переопределении 
необходимо соблюдать **пять обязательных свойств**, описанных в спецификации Java:

#### 1. Рефлексивность (Reflexive)
Объект всегда должен быть равен самому себе:
```java
x.equals(x) == true  // для любого ненулевого x
```

#### 2. Симметричность (Symmetric)
Если `x` равен `y`, то `y` должен быть равен `x`:
```java
x.equals(y) == y.equals(x)  // для любых ненулевых x и y
```

> **Важно**: Нарушение симметричности часто возникает при сравнении объектов разных классов или при некорректной работе с 
> наследованием.

#### 3. Транзитивность (Transitive)
Если `x` равен `y`, и `y` равен `z`, то `x` должен быть равен `z`:
```java
if (x.equals(y) && y.equals(z)) {
    x.equals(z) == true
}
```

#### 4. Согласованность (Consistent)
Множественные вызовы `equals()` должны возвращать одинаковый результат, если объекты не изменялись:
```java
x.equals(y) == x.equals(y)  // при повторном вызове
```

> **Важно**: Не используйте изменяемые или недетерминированные поля (например, `Random`, текущее время) в реализации `equals()`.

#### 5. Сравнение с null
Любой ненулевой объект не должен быть равен `null`:
```java
x.equals(null) == false  // для любого ненулевого x
```

### Контракт hashCode

Метод `hashCode()` возвращает целочисленное значение, используемое для размещения объектов в хеш-таблицах. Контракт `hashCode()` 
жёстко связан с `equals()` и определяет три обязательных правила:

#### 1. Согласованность
При многократном вызове `hashCode()` для неизменённого объекта должно возвращаться одно и то же значение:
```java
int hash1 = obj.hashCode();
int hash2 = obj.hashCode();
// hash1 == hash2, если obj не изменялся
```

#### 2. Равные объекты должны иметь одинаковый hash-код
Это **критическое правило**:
```java
if (x.equals(y)) {
    x.hashCode() == y.hashCode()  // ОБЯЗАТЕЛЬНО
}
```

> **Важно**: Нарушение этого правила приводит к тому, что равные объекты попадают в разные бакеты хеш-таблицы, и коллекция 
> не может их найти.

#### 3. Разные объекты могут иметь одинаковый hash-код (но желательно разный)
Обратное не обязательно — неравные объекты **могут** иметь одинаковый `hashCode()`:
```java
if (x.hashCode() == y.hashCode()) {
    x.equals(y)  // не обязательно true
}
```

Однако для эффективности желательно минимизировать **коллизии** (ситуации, когда разные объекты имеют одинаковый hash-код). 
Большое количество коллизий деградирует производительность `HashMap`/`HashSet` до O(n).

### Связь equals и hashCode в коллекциях

#### HashMap и HashSet

`HashMap` использует `hashCode()` для определения индекса бакета:
```java
int bucket = (hash & (table.length - 1));
```

Внутри бакета элементы сравниваются через `equals()`. Процесс добавления элемента:

1. Вычисляется `hashCode()` ключа
2. Определяется бакет на основе hash-кода
3. Если бакет пустой — элемент добавляется
4. Если бакет не пустой — перебираются элементы и сравниваются через `equals()`
5. Если найден равный элемент — значение заменяется (для `Map`) или элемент отклоняется (для `Set`)
6. Если равного нет — элемент добавляется в цепочку/дерево

**Пример проблемы при нарушении контракта:**
```java
class BadKey {
    private int value;
    
    public BadKey(int value) {
        this.value = value;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof BadKey)) return false;
        return this.value == ((BadKey) obj).value;
    }
    
    // hashCode() НЕ переопределён! Используется дефолтная реализация из Object
}

Map<BadKey, String> map = new HashMap<>();
map.put(new BadKey(1), "one");
String result = map.get(new BadKey(1));  // result == null!
```

Даже если два объекта `BadKey` с `value=1` равны по `equals()`, они имеют разные hash-коды и попадают в разные бакеты. 
Метод `get()` не найдёт значение.

#### TreeSet и TreeMap

`TreeSet` и `TreeMap` не используют `hashCode()`, полагаясь на `Comparator` или `Comparable`. Однако важно, чтобы реализация 
`compareTo()` была **согласована с `equals()`**:
```java
// Правильно: если compareTo возвращает 0, то equals возвращает true
(x.compareTo(y) == 0) == x.equals(y)
```

Нарушение этого правила приводит к противоречивому поведению при переносе объектов между разными типами коллекций.

### Правильная реализация

#### Шаблон реализации equals

```java
public class Person {
    private final String name;
    private final int age;
    private final String email;
    
    @Override
    public boolean equals(Object obj) {
        // 1. Проверка на идентичность (оптимизация)
        if (this == obj) {
            return true;
        }
        
        // 2. Проверка на null и тип
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        
        // 3. Приведение типа
        Person other = (Person) obj;
        
        // 4. Сравнение значимых полей
        return age == other.age &&
               Objects.equals(name, other.name) &&
               Objects.equals(email, other.email);
    }
}
```

> **Совет**: Используйте `Objects.equals()` для сравнения полей-ссылок, чтобы корректно обрабатывать `null`.

#### Шаблон реализации hashCode

```java
@Override
public int hashCode() {
    return Objects.hash(name, age, email);
}
```

Метод `Objects.hash()` (Java 7+) автоматически вычисляет hash-код на основе переданных полей. Эквивалентная ручная реализация:

```java
@Override
public int hashCode() {
    int result = 17;  // Начальное простое число
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + age;
    result = 31 * result + (email != null ? email.hashCode() : 0);
    return result;
}
```

> **Почему 31?** Это простое число, достаточно большое для минимизации коллизий, но достаточно маленькое, чтобы избежать 
> переполнения. Кроме того, умножение на 31 оптимизируется JVM как `(i << 5) - i`.

#### Использование IDE или утилит

Современные IDE (IntelliJ IDEA, Eclipse) и библиотеки (Lombok, Apache Commons) могут автоматически генерировать `equals()` 
и `hashCode()`:

```java
// Lombok
@EqualsAndHashCode
public class Person {
    private final String name;
    private final int age;
}

// Java 16+ Record (автоматически генерирует equals, hashCode, toString)
public record Person(String name, int age) {}
```

### Распространённые ошибки

#### 1. Переопределение только equals без hashCode

```java
class WrongPerson {
    private String name;
    
    @Override
    public boolean equals(Object obj) {
        // ... корректная реализация
    }
    
    // hashCode() НЕ переопределён!
}

Set<WrongPerson> set = new HashSet<>();
set.add(new WrongPerson("Alice"));
set.add(new WrongPerson("Alice"));  // Добавится второй раз!
System.out.println(set.size());  // 2 вместо ожидаемого 1
```

#### 2. Использование изменяемых полей

```java
class MutableKey {
    private String value;  // изменяемое поле!
    
    public void setValue(String value) {
        this.value = value;
    }
    
    @Override
    public boolean equals(Object obj) {
        return value.equals(((MutableKey) obj).value);
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }
}

Map<MutableKey, String> map = new HashMap<>();
MutableKey key = new MutableKey();
key.setValue("original");
map.put(key, "data");

key.setValue("modified");  // Изменение ключа!
String result = map.get(key);  // null! Ключ попал в другой бакет
```

> **Совет**: Используйте только **неизменяемые поля** в реализации `equals()` и `hashCode()`. Для ключей `Map` и элементов 
> `Set` делайте объекты полностью иммутабельными (final поля, отсутствие setter-ов).

#### 3. Несимметричность при работе с наследованием

```java
class Point {
    private int x, y;
    
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Point)) return false;
        Point p = (Point) obj;
        return x == p.x && y == p.y;
    }
}

class ColorPoint extends Point {
    private String color;
    
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof ColorPoint)) return false;
        ColorPoint cp = (ColorPoint) obj;
        return super.equals(cp) && color.equals(cp.color);
    }
}

Point p = new Point(1, 2);
ColorPoint cp = new ColorPoint(1, 2, "red");

p.equals(cp);   // true (Point игнорирует color)
cp.equals(p);   // false (ColorPoint требует color)
// Нарушение симметричности!
```

**Решение**: Используйте композицию вместо наследования для изменяемой логики `equals()`, или сравнивайте `getClass()` 
вместо `instanceof`:

```java
@Override
public boolean equals(Object obj) {
    if (obj == null || getClass() != obj.getClass()) return false;
    // ...
}
```

#### 4. Игнорирование null в полях

```java
class BadEquals {
    private String name;
    
    @Override
    public boolean equals(Object obj) {
        BadEquals other = (BadEquals) obj;
        return name.equals(other.name);  // NullPointerException если name == null!
    }
}
```

**Решение**: Используйте `Objects.equals()`:
```java
return Objects.equals(name, other.name);
```

#### 5. Использование недетерминированных значений

```java
class WrongHash {
    @Override
    public int hashCode() {
        return new Random().nextInt();  // НЕПРАВИЛЬНО! Каждый раз новое значение
    }
}
```

## Generics и типобезопасность
Generics появились в Java 5 и реализованы через стирание типов (type erasure). Во время компиляции создаётся специализированный
байт-код, но в рантайме все обобщённые типы приводятся к `Object`. Это позволяет поддерживать обратную совместимость, но влечёт
ограничения: нельзя создавать массивы обобщённых типов (`new T[]`), нельзя использовать примитивы без обёрток.

Используйте ограниченные параметры (`<T extends Comparable<T>>`), wildcard (`?`, `? extends`, `? super`) для ковариантности и
контравариантности. Соблюдайте правило PECS (Producer Extends, Consumer Super) при работе с коллекциями.

## Специализированные коллекции
- **Immutable Collections**: `List.of`, `Set.of`, `Map.of` — неизменяемые структуры. В многопоточном окружении безопасны для
  совместного чтения, но не допускают изменений.
- **EnumSet/EnumMap**: оптимизированы для перечислений, используют битовые наборы. Для потокобезопасности — внешняя
  синхронизация либо создание неизменяемых копий.
- **Concurrent Collections**: `ConcurrentSkipListMap`, `ConcurrentLinkedDeque`, `CopyOnWriteArraySet`. Предоставляют готовые
  механизмы синхронизации или неблокирующие алгоритмы, снижая количество ручных блокировок.

## Best practices
- Выбирайте интерфейсы в сигнатурах (`List` вместо `ArrayList`).
- Используйте `Collections.unmodifiableList` или неизменяемые коллекции для защиты API.
- Всегда переопределяйте `equals()` и `hashCode()` в паре для ключей `Map` и элементов `Set` (см. раздел [Контракты equals и hashCode](#контракты-equals-и-hashcode)).
- Для крупных коллекций контролируйте initial capacity (`new HashMap<>(capacity, loadFactor)`).

## Практические упражнения
1. Реализуйте собственный `LRUCache` на основе `LinkedHashMap` и протестируйте его потокобезопасность.
2. Сравните время выполнения операций `get`/`put` для `HashMap`, `ConcurrentHashMap`, `TreeMap` при разных объёмах данных.
3. Напишите API, принимающий `List<? extends Number>`, и объясните, почему нельзя добавлять элементы в такую коллекцию.
4. Создайте класс `Employee` с полями `id`, `name`, `department`. Реализуйте корректные `equals()` и `hashCode()`, затем 
   продемонстрируйте проблему, возникающую при изменении поля после добавления объекта в `HashSet`.

## Вопросы на собеседовании
1. **Почему generics реализованы через стирание типов?**
   *Ответ:* Для сохранения совместимости со старым байт-кодом и JVM. Старые библиотеки, не использующие generics, продолжают
   работать без изменений, а компилятор обеспечивает проверку типов на этапе компиляции.
2. **Что такое правило PECS?**
   *Ответ:* Producer Extends, Consumer Super. Если коллекция предоставляет элементы (producer), используйте `? extends T`. Если
   коллекция принимает элементы (consumer), используйте `? super T`.
3. **Как `HashMap` справляется с коллизиями?**
   *Ответ:* Коллизии сначала формируют связный список. Если цепочка превышает порог (по умолчанию 8) и размер массива >= 64,
   структура превращается в красно-чёрное дерево, что уменьшает сложность операций до O(log n).
4. **Чем отличаются `HashMap` и `ConcurrentHashMap`?**
   *Ответ:* `ConcurrentHashMap` поддерживает одновременные операции без глобальной блокировки, деля таблицу на сегменты и
   используя CAS. Он запрещает `null` ключи/значения и предоставляет дополнительные атомарные операции (`computeIfAbsent`).
5. **Когда стоит предпочесть неизменяемые коллекции?**
   *Ответ:* Когда нужно обеспечить потокобезопасность и защиту от случайной модификации. Иммутабельные коллекции сокращают
   количество защитных копий и упрощают reasoning.
6. **Какие свойства должен соблюдать контракт equals?**
   *Ответ:* Пять обязательных свойств: рефлексивность (x.equals(x) == true), симметричность (x.equals(y) == y.equals(x)), 
   транзитивность (если x.equals(y) и y.equals(z), то x.equals(z)), согласованность (повторные вызовы возвращают тот же результат) 
   и x.equals(null) == false для любого ненулевого x.
7. **Что произойдёт, если переопределить equals, но не переопределить hashCode?**
   *Ответ:* Нарушится контракт: равные по equals объекты могут иметь разные hash-коды, что приведёт к некорректной работе 
   HashMap/HashSet. Например, элемент не будет найден методом get(), даже если он есть в коллекции, или Set будет содержать дубликаты.
8. **Почему в реализации hashCode часто используется число 31?**
   *Ответ:* 31 — простое число, достаточно большое для минимизации коллизий, но при этом умножение на 31 эффективно оптимизируется 
   JVM как побитовый сдвиг: `31 * i == (i << 5) - i`. Это обеспечивает баланс между производительностью и качеством распределения.
9. **Можно ли использовать изменяемые поля в equals и hashCode?**
   *Ответ:* Технически можно, но это плохая практика. Если объект используется как ключ в Map или элемент в Set, изменение его 
   состояния после добавления нарушит инварианты коллекции: элемент попадёт в неправильный бакет и станет недоступен для поиска. 
   Рекомендуется использовать только неизменяемые (final) поля или делать такие объекты полностью иммутабельными.
10. **Как правильно реализовать equals при наследовании?**
    *Ответ:* Наследование создаёт проблему с симметричностью equals. Рекомендации: 1) Использовать композицию вместо наследования 
    для классов с разной логикой сравнения; 2) Сравнивать через getClass() вместо instanceof, чтобы объекты разных классов не 
    считались равными; 3) Или делать базовый класс абстрактным и запрещать сравнение между подклассами. Идеальное решение — 
    использовать record (Java 16+) или иммутабельные классы, где наследование не требуется.
