# Коллекции и обобщения

## Каркас коллекций Java
Стандартный пакет `java.util` задаёт каркас через интерфейсы `Collection`, `List`, `Set`, `Queue`, `Deque`, `Map`. Каждый
интерфейс описывает контракт по операциям, а конкретные структуры выбираются в зависимости от требуемых сложностей,
гарантий порядка и потокобезопасности.

### List
**List** обеспечивает упорядоченный набор элементов с доступом по индексу и поддержкой дубликатов.

- **`ArrayList`**. Хранит данные в динамическом массиве. При переполнении ёмкость увеличивается примерно на 50 %, копируя
  элементы в новый массив. Вставка и удаление из середины требуют сдвига элементов, но чтение по индексу выполняется за O(1).
  В многопоточном коде не потокобезопасен: требуется внешняя синхронизация (`Collections.synchronizedList`) или использование
  неизменяемой копии. Итератор fail-fast — при структурных изменениях в другом потоке он бросает `ConcurrentModificationException`.
- **`LinkedList`**. Построен на двусвязных узлах `Node` с полями `item`, `prev`, `next`. Добавление и удаление с концов
  выполняются за O(1), поиск по индексу — за O(n). В многопоточном окружении также требует синхронизации; кроме того,
  итерация небезопасна без внешних блокировок.
- **`CopyOnWriteArrayList`**. Для каждой структурной модификации создаёт новый массив. Чтения выполняются без блокировок и не
  видят незавершённых изменений. Подходит для сценариев «много чтений, мало записей». Итераторы не fail-fast: они работают с
  моментальным снимком. Записи дорогие по памяти и времени, поэтому в многопоточности подходит для конфигурационных списков,
  событийных слушателей и т.п.

### Set
**Set** хранит уникальные элементы без дубликатов. Гарантии по порядку зависят от реализации.

- **`HashSet`**. Реализован поверх `HashMap`, где элементы выступают ключами, а значением служит заглушка. Использует массив
  бакетов с цепочками или сбалансированными деревьями при длинных цепях. В многопоточности не потокобезопасен; необходимо
  внешнее блокирование. Fail-fast итераторы ведут себя аналогично `ArrayList`.
- **`LinkedHashSet`**. Сохраняет порядок вставки благодаря двусвязному списку поверх `HashSet`. Потокобезопасность аналогична
  `HashSet` — требуется внешняя синхронизация.
- **`TreeSet`**. Использует `NavigableMap` (по умолчанию `TreeMap`) с красно-чёрным деревом. Поддерживает сортированный порядок,
  операции навигации (`higher`, `lower`, `subSet`). Не потокобезопасен; при совместном доступе необходимы блокировки либо
  замена на `ConcurrentSkipListSet`.
- **`EnumSet`**. Внутренне — битовый набор (один или несколько `long`), поэтому операции выполняются очень быстро. Потокобезопасность
  не обеспечивается, но благодаря неизменяемости набора перечислений (фиксированное количество значений) легко создавать
  неизменяемые снапшоты и использовать `Collections.synchronizedSet` при необходимости.

### Queue и Deque
**Queue/Deque** предоставляют операции FIFO или двустороннего доступа.

- **`ArrayDeque`**. Кольцевой буфер на массиве. Поддерживает операции стека и очереди за O(1). Не блокирующая и
  непотокобезопасная: синхронизируйте при совместном доступе или используйте `ConcurrentLinkedDeque`.
- **`PriorityQueue`**. Реализует двоичную кучу (min-heap). Операции `offer`/`poll` выполняются за O(log n), доступ к минимальному
  элементу — O(1). Итератор не гарантирует порядок. Потокобезопасность отсутствует; для многопоточности используйте `PriorityBlockingQueue`
  или внешние блокировки.
- **`ConcurrentLinkedQueue`**. Неблокирующая очередь FIFO на связном списке с атомарными операциями (CAS). Поддерживает высокую
  конкуренцию без блокировок, но не подходит для структур, требующих ограниченной ёмкости. Итерации слабосогласованные — могут
  пропускать или повторять элементы, если очередь изменяется во время обхода.
- **`BlockingQueue`** (например, `ArrayBlockingQueue`, `LinkedBlockingQueue`). Предоставляют операции, ожидающие появления
  свободного места или элемента. Используют внутренние блокировки (`ReentrantLock`) и условные переменные. Потокобезопасны, но
  возможна конкуренция между производителями/потребителями; важно выбирать правильную ёмкость и стратегию обработки прерываний.

### Map
**Map** отображает ключи в значения, может поддерживать порядок или особенности хранения ссылок.

- **`HashMap`**. Массив бакетов с цепочками (`Node<K,V>`). При длинных цепочках (>=8) и достаточной ёмкости бакет превращается
  в красно-чёрное дерево. Рехеширование происходит при превышении `loadFactor`. Потокобезопасность отсутствует; конкурентный
  доступ может приводить к потерям данных. При необходимости используйте `Collections.synchronizedMap` или другие реализации.
- **`LinkedHashMap`**. Наследует `HashMap`, добавляя двусвязный список для порядка вставки или доступа (`accessOrder=true`). Часто
  применяется для LRU-кэшей. Потокобезопасность требует внешней синхронизации.
- **`TreeMap`**. Красно-чёрное дерево, реализующее `NavigableMap`. Обеспечивает отсортированные ключи и диапазонные операции.
  В многопоточности следует применять `Collections.synchronizedSortedMap` или `ConcurrentSkipListMap`.
- **`ConcurrentHashMap`**. В Java 8 использует массив бакетов с узлами и синхронизацию на уровне цепочек с помощью CAS и
  `synchronized` на отдельных бакетах при рехешировании. Обеспечивает неблокирующие чтения и ограниченную блокировку при записях.
  Итераторы слабосогласованные: отражают состояние на момент запуска и могут видеть некоторые последующие изменения. Поддерживает
  атомарные операции (`compute`, `merge`, `forEach`) с учётом многопоточности.
- **`WeakHashMap`**. Хранит ключи через `WeakReference`. Когда на ключ больше нет сильных ссылок, запись удаляется GC. Использует
  `ReferenceQueue` для очистки. Потокобезопасности нет; для многопоточности применяют внешнюю синхронизацию или `ConcurrentHashMap`
  с обёртками на слабых ссылках из сторонних библиотек.

## Generics и типобезопасность
Generics появились в Java 5 и реализованы через стирание типов (type erasure). Во время компиляции создаётся специализированный
байт-код, но в рантайме все обобщённые типы приводятся к `Object`. Это позволяет поддерживать обратную совместимость, но влечёт
ограничения: нельзя создавать массивы обобщённых типов (`new T[]`), нельзя использовать примитивы без обёрток.

Используйте ограниченные параметры (`<T extends Comparable<T>>`), wildcard (`?`, `? extends`, `? super`) для ковариантности и
контравариантности. Соблюдайте правило PECS (Producer Extends, Consumer Super) при работе с коллекциями.

## Специализированные коллекции
- **Immutable Collections**: `List.of`, `Set.of`, `Map.of` — неизменяемые структуры. В многопоточном окружении безопасны для
  совместного чтения, но не допускают изменений.
- **EnumSet/EnumMap**: оптимизированы для перечислений, используют битовые наборы. Для потокобезопасности — внешняя
  синхронизация либо создание неизменяемых копий.
- **Concurrent Collections**: `ConcurrentSkipListMap`, `ConcurrentLinkedDeque`, `CopyOnWriteArraySet`. Предоставляют готовые
  механизмы синхронизации или неблокирующие алгоритмы, снижая количество ручных блокировок.

## Best practices
- Выбирайте интерфейсы в сигнатурах (`List` вместо `ArrayList`).
- Используйте `Collections.unmodifiableList` или неизменяемые коллекции для защиты API.
- Не забывайте про `equals`/`hashCode` для ключей `Map` и элементов `Set`.
- Для крупных коллекций контролируйте initial capacity (`new HashMap<>(capacity, loadFactor)`).

## Практические упражнения
1. Реализуйте собственный `LRUCache` на основе `LinkedHashMap` и протестируйте его потокобезопасность.
2. Сравните время выполнения операций `get`/`put` для `HashMap`, `ConcurrentHashMap`, `TreeMap` при разных объёмах данных.
3. Напишите API, принимающий `List<? extends Number>`, и объясните, почему нельзя добавлять элементы в такую коллекцию.

## Вопросы на собеседовании
1. **Почему generics реализованы через стирание типов?**
   *Ответ:* Для сохранения совместимости со старым байт-кодом и JVM. Старые библиотеки, не использующие generics, продолжают
   работать без изменений, а компилятор обеспечивает проверку типов на этапе компиляции.
2. **Что такое правило PECS?**
   *Ответ:* Producer Extends, Consumer Super. Если коллекция предоставляет элементы (producer), используйте `? extends T`. Если
   коллекция принимает элементы (consumer), используйте `? super T`.
3. **Как `HashMap` справляется с коллизиями?**
   *Ответ:* Коллизии сначала формируют связный список. Если цепочка превышает порог (по умолчанию 8) и размер массива >= 64,
   структура превращается в красно-чёрное дерево, что уменьшает сложность операций до O(log n).
4. **Чем отличаются `HashMap` и `ConcurrentHashMap`?**
   *Ответ:* `ConcurrentHashMap` поддерживает одновременные операции без глобальной блокировки, деля таблицу на сегменты и
   используя CAS. Он запрещает `null` ключи/значения и предоставляет дополнительные атомарные операции (`computeIfAbsent`).
5. **Когда стоит предпочесть неизменяемые коллекции?**
   *Ответ:* Когда нужно обеспечить потокобезопасность и защиту от случайной модификации. Иммутабельные коллекции сокращают
   количество защитных копий и упрощают reasoning.
