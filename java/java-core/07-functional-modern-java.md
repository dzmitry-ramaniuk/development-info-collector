# Функциональные возможности и современные фичи Java


## Содержание

1. [Lambda-выражения и функциональные интерфейсы](#lambda-выражения-и-функциональные-интерфейсы)
   - [Замыкания и область видимости](#замыкания-и-область-видимости)
2. [Stream API](#stream-api)
3. [Optional и null-safety](#optional-и-null-safety)
4. [Современные фичи языка](#современные-фичи-языка)
5. [Реактивное программирование и асинхронность](#реактивное-программирование-и-асинхронность)
6. [Инструменты для функционального стиля](#инструменты-для-функционального-стиля)
7. [Практические упражнения](#практические-упражнения)
8. [Вопросы на собеседовании](#вопросы-на-собеседовании)

## Lambda-выражения и функциональные интерфейсы
Lambda-выражения позволяют передавать поведение как значение. Функциональный интерфейс содержит ровно один абстрактный метод
(`@FunctionalInterface`). В стандартной библиотеке есть заготовки (`Function`, `Supplier`, `Consumer`, `Predicate`,
`UnaryOperator`, `BiFunction`). Используйте лямбды для описания действий в Stream API, обработчиков событий, коллбеков.

### Замыкания и область видимости
Лямбда захватывает переменные из внешнего контекста, если они effectively final. Это означает, что переменные не должны
изменяться после присваивания. Такая модель упрощает потокобезопасность и JIT-оптимизации.

## Stream API
Stream — ленивое представление последовательности данных, поддерживающее преобразования (`map`, `filter`, `flatMap`), сортировки,
промежуточные операции (`peek`, `distinct`) и терминальные (`collect`, `reduce`, `forEach`).

- **Создание**: `Stream.of`, `Arrays.stream`, `Collection.stream`, `Stream.generate`, `Stream.iterate`.
- **Коллекторы**: `Collectors.toList`, `toSet`, `joining`, `groupingBy`, `partitioningBy`. Пользовательские коллекторы создаются
  через `Collector.of`.
- **Параллельные стримы**: `parallelStream()` использует ForkJoinPool. Эффективны для CPU-bound задач с независимыми операциями.
- **Особенности**: избегайте состояния внутри лямбд, следите за порядком операций (`sorted`, `limit`).

## Optional и null-safety
`Optional` помогает явно выразить отсутствие значения. Используйте `Optional.of`, `Optional.ofNullable`, `Optional.empty`.
Методы `map`, `flatMap`, `orElse`, `orElseGet`, `orElseThrow` упрощают обработку. Не злоупотребляйте `Optional` в полях и
сериализации — объект весит больше и не предназначен для коллекций как ключ.

## Современные фичи языка
- **var (Java 10)** — вывод типа локальных переменных.
- **Records (Java 16)** — компактные классы с автоматической генерацией конструктора, `equals`, `hashCode`, `toString`.
- **Pattern Matching**: `instanceof` с привязкой переменной (Java 16), `switch`-паттерны (preview в Java 19+).
- **Text Blocks (Java 15)** — многострочные литералы.
- **Sealed классы (Java 17)** — ограничение наследования.
- **Virtual Threads (Project Loom, Java 21)** — лёгкие потоки для масштабируемости.

## Реактивное программирование и асинхронность
- **CompletableFuture**: предоставляет комбинаторы (`thenApply`, `thenCompose`, `allOf`, `exceptionally`). Используйте кастомные
  `Executor`, чтобы контролировать потоки.
- **Reactive Streams**: Flow API (Java 9) содержит `Publisher`, `Subscriber`, `Processor`. Популярные реализации — Project
  Reactor, RxJava.
- **Structured Concurrency** (Incubator в Java 21) — координация подзадач и автоматическое управление отменой.

## Инструменты для функционального стиля
- Используйте `Collectors.teeing`, `Collectors.flatMapping` для сложных агрегатов.
- Применяйте `Map.of`, `Set.of` для неизменяемых структур.
- Лямбды и ссылки на методы (`String::toUpperCase`) улучшают читаемость.
- Для pattern matching полезны библиотеки Vavr, позволяющие писать выражения `match` и работать с персистентными коллекциями.

## Практические упражнения
1. Обработайте CSV-файл с помощью Stream API: сгруппируйте данные, вычислите агрегаты, выведите JSON.
2. Напишите цепочку `CompletableFuture`, выполняющую запросы к REST API параллельно и объединяющую результаты.
3. Реализуйте собственный коллектор, собирающий статистику (минимум, максимум, среднее) по потоку чисел.

## Вопросы на собеседовании
1. **Чем отличаются `map` и `flatMap` в Stream API?**
   *Ответ:* `map` применяет функцию к каждому элементу и возвращает поток результатов, `flatMap` раскрывает вложенные потоки или
   коллекции, превращая их в единый поток.
2. **Как работает `Optional.orElse` в сравнении с `orElseGet`?**
   *Ответ:* `orElse` вычисляет аргумент всегда, даже если значение присутствует. `orElseGet` принимает `Supplier` и вычисляет
   значение лениво, только при отсутствии данных.
3. **Почему не стоит использовать `Optional` в полях сущностей?**
   *Ответ:* `Optional` предназначен для возвращаемых значений. В полях он добавляет накладные расходы (дополнительный объект),
   усложняет сериализацию и JPA/JSON-биндинг.
4. **В чём преимущества `record` по сравнению с обычными классами?**
   *Ответ:* `record` автоматически генерирует конструктор, `equals`, `hashCode`, `toString`, обеспечивает иммутабельность и чётко
   описывает компоненты. Подходит для DTO и value-объектов.
5. **Зачем нужны виртуальные потоки (Project Loom)?**
   *Ответ:* Virtual threads позволяют запускать тысячи легковесных задач поверх небольшого пула carrier threads. Они упрощают
   масштабирование I/O-нагруженных приложений, не требуя сложной реактивной архитектуры.
