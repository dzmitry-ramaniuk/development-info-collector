# Объектно-ориентированное программирование в Java

## Классы, интерфейсы и наследование
Класс описывает состояние и поведение объекта; в Java каждый файл обычно содержит один `public` класс. Наследование (`extends`) позволяет переиспользовать код, но должно применяться осознанно, чтобы избежать хрупких иерархий. Интерфейсы описывают контракт поведения. С Java 8 они поддерживают `default` и `static` методы, а также приватные методы-помощники. Абстрактные классы сочетают общую реализацию и незаполненные методы. Ключевое слово `sealed` (Java 17) ограничивает круг наследников, а `record` упрощает создание неизменяемых DTO с автоматическим `equals`, `hashCode` и `toString`.

## Полиморфизм и композиция
Полиморфизм позволяет вызывать методы по интерфейсу, а конкретный класс выбирается в runtime. Это снижает связанность и упрощает тестирование (через внедрение зависимостей и моки). Композиция часто предпочтительнее наследования: объект включает другие объекты и делегирует им работу, что позволяет менять поведение без изменения иерархии. Применение SOLID-принципов (особенно единственной ответственности и инверсии зависимостей) помогает удерживать модульность и читаемость кода.

## Инкапсуляция и управление состоянием
Инкапсуляция скрывает внутреннее состояние за публичным API. Поля объявляются `private`, а доступ предоставляется через геттеры/сеттеры или методы бизнес-логики. Неизменяемые объекты делают поля `final`, инициализируют их в конструкторе и не предоставляют сеттеров. Они безопасны в многопоточности и упрощают кеширование. Мутируемые объекты требуют контроля инвариантов: проверки входных данных, защитное копирование коллекций и синхронизацию при доступе из нескольких потоков.

## Шаблоны проектирования и практики
- **Builder** упрощает создание сложных объектов с множеством параметров, избегая длинных конструкторов.  
- **Factory Method** и **Abstract Factory** скрывают логику создания, позволяя подменять реализации интерфейсов.  
- **Strategy** инкапсулирует взаимозаменяемые алгоритмы.  
- **Template Method** фиксирует последовательность операций, делегируя вариации подклассам.  
В Java также распространены DI-фреймворки (Spring, CDI), реализующие инверсию управления, и `Optional` для избегания `null`. Для тестируемости используйте интерфейсы, внедряйте зависимости через конструктор, покрывайте публичные контрактные методы unit-тестами.

## Вопросы на собеседовании
1. **В чём разница между интерфейсом и абстрактным классом?**  
   *Ответ:* Интерфейс описывает контракт и допускает множественное наследование; реализацию обязуются предоставить классы. Абстрактный класс может содержать общее состояние и реализацию, поддерживает только одиночное наследование. Выбор зависит от необходимости разделяемого состояния и количества предполагаемых родителей.
2. **Когда стоит использовать композицию вместо наследования?**  
   *Ответ:* Когда поведение можно выразить через делегирование и нет строгого отношения «является». Композиция упрощает замену зависимостей, избегает проблем хрупкого базового класса, облегчает тестирование. Наследование оправдано при расширении базового типа с сохранением его инвариантов.
3. **Зачем нужны `record` и какие ограничения у них есть?**  
   *Ответ:* `record` генерирует неизменяемый класс данных с автоматическими методами `equals`, `hashCode`, `toString` и каноническим конструктором. Ограничения: они не могут наследоваться от других классов (кроме `Record`), все поля — компоненты записи, и нельзя изменять их после создания.
4. **Что такое принцип единственной ответственности?**  
   *Ответ:* Класс должен иметь одну причину для изменения. Если объект отвечает за несколько обязанностей (например, хранение данных и доступ к базе), его изменения затронут множество клиентов и усложнят поддержку. Выделение отдельных классов для каждой задачи повышает устойчивость к изменениям.
5. **Как реализовать неизменяемый класс в Java?**  
   *Ответ:* Сделать поля `private final`, не предоставлять сеттеров, инициализировать все поля в конструкторе или фабричном методе. Возвращать защитные копии изменяемых коллекций и объектов, переопределить `equals`/`hashCode`. Использование `record` автоматизирует большую часть этих шагов.
