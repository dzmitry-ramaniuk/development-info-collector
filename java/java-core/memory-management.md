# Управление памятью и сборка мусора

## Области памяти JVM
Heap хранит объекты и делится на молодое поколение (Eden + Survivor) и старшее поколение. Молодое поколение оптимизировано под частые короткоживущие объекты, а старшее — под долгоживущие. Stack выделяется для каждого потока и содержит фреймы вызовов с локальными переменными и операндами. Metaspace хранит метаданные классов и структуру методов, а также таблицы виртуальных вызовов. Code Cache содержит машинный код, сгенерированный JIT-компилятором. Понимание распределения памяти помогает настраивать параметры `-Xms`, `-Xmx`, `-XX:NewRatio`, `-XX:MetaspaceSize`.

## Алгоритмы сборки мусора
Сборщики мусора в HotSpot основаны на стратегии «mark-and-sweep», но реализуют разные компромиссы:
- **Serial GC**: один поток, простая реализация — подходит для небольших heap до нескольких сотен мегабайт.  
- **Parallel GC**: несколько потоков отмечают и освобождают память, оптимизирован для throughput.  
- **G1 GC**: делит heap на регионы, позволяет тонко контролировать паузы, ориентирован на серверные приложения.  
- **ZGC/Shenandoah**: работа с очень большими кучами с паузами <10 мс благодаря concurrent-компакции.  
Выбор GC зависит от целевых задержек и пропускной способности. Настройка проводится экспериментально с помощью профилирования GC-логов.

## Жизненный цикл объекта
1. Создание объекта происходит через оператор `new` или рефлексию; память выделяется в Eden.  
2. Когда Eden заполняется, выполняется minor GC: живые объекты копируются в survivor-области или промотируются в старшее поколение.  
3. Major GC чистит старшее поколение, может сопровождаться паузами. Современные GC (G1, ZGC) стремятся выполнять больше работы параллельно и конкурентно, чтобы минимизировать stop-the-world.  
4. Финализация и очистка ресурсов выполняются только при необходимости; рекомендуется использовать `try-with-resources` или явное закрытие.

## Диагностика утечек и настройка
Сбор и анализ GC-логов (`-Xlog:gc*`) позволяет измерять паузы и эффективность коллектора. Инструменты `jmap`, `MAT`, `VisualVM`, `Eclipse Memory Analyzer` помогают находить утечки через heap dump. Escape-анализ JIT позволяет размещать короткоживущие объекты на стеке или в регистрах. Параметры `-XX:+UseStringDeduplication`, `-XX:+AlwaysPreTouch` и профилирование аллокаций (`jfr`, async-profiler) помогают оптимизировать распределение памяти.

## Вопросы на собеседовании
1. **Как устроена куча JVM и зачем нужны поколения?**  
   *Ответ:* Heap делится на молодое и старшее поколение. Большинство объектов живут недолго, поэтому minor GC может быстро очищать Eden, копируя живые объекты в survivor-области. Долгоживущие объекты продвигаются в старшее поколение, где сборка происходит реже. Это повышает эффективность за счёт локализации работы GC.
2. **Чем отличаются Serial, Parallel и G1 GC?**  
   *Ответ:* Serial работает в одном потоке и подходит для небольших приложений. Parallel использует несколько потоков, уменьшая длительность пауз, но всё ещё выполняет stop-the-world. G1 делит heap на регионы и выполняет сборку инкрементально, позволяя задавать целевые паузы и работать эффективно с большими кучами.
3. **Когда объект считается доступным для сборки мусора?**  
   *Ответ:* Когда на него больше нет достижимых сильных ссылок из корневого множества (стеков потоков, статических полей, JNI-ссылок). Сборщик мусора строит граф достижимости и освобождает объекты, до которых нельзя добраться.
4. **Как обнаружить утечку памяти в приложении?**  
   *Ответ:* Включить подробные GC-логи для наблюдения роста кучи, снять heap dump (`jmap -dump` или JFR), открыть его в анализаторе (MAT, VisualVM) и посмотреть доминирующие объекты и удерживающие цепочки. Также полезно настроить профилирование аллокаций и проверку кода на зависшие коллекции и кеши.
5. **Что такое `OutOfMemoryError: Metaspace` и как его устранить?**  
   *Ответ:* Metaspace хранит метаданные классов; ошибка возникает при динамической загрузке множества классов (генераторы прокси, OSGi, приложения с плагинами). Решение — увеличить `-XX:MaxMetaspaceSize`, оптимизировать количество генерируемых классов (кеширование proxy), корректно выгружать классы при закрытии ClassLoader.
