# Объектно-ориентированное программирование в Java


## Содержание

1. [Принципы проектирования](#принципы-проектирования)
2. [Проектирование классов и API](#проектирование-классов-и-api)
3. [Паттерны проектирования](#паттерны-проектирования)
4. [Работа с интерфейсами и абстракциями](#работа-с-интерфейсами-и-абстракциями)
5. [Архитектурные подходы](#архитектурные-подходы)
6. [Практические упражнения](#практические-упражнения)
7. [Вопросы на собеседовании](#вопросы-на-собеседовании)

## Принципы проектирования
- **Инкапсуляция** — скрывайте внутреннее состояние за методами доступа. Используйте `private` поля и иммутабельные объекты,
  где это возможно.
- **Наследование** — применяйте для моделирования отношения «is-a». Не злоупотребляйте глубокой иерархией; если требуется
  совместное поведение, подумайте о композиции.
- **Полиморфизм** — интерфейсы и абстрактные классы позволяют подменять реализации и строить расширяемые API.
- **SOLID** — Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion. В Java
  эти принципы реализуются через интерфейсы, фабрики, DI-фреймворки.

## Проектирование классов и API
1. **Иммутабельность**: делайте классы неизменяемыми, когда это возможно. Используйте `record`, `Builder`.
2. **Контракты equals/hashCode**: переопределяйте в паре. Соблюдайте рефлексивность, симметричность, транзитивность.
3. **Comparable и Comparator**: реализуйте естественный порядок (`Comparable`) и внешние сравнения (`Comparator.comparing`).
4. **Фабрики и конструкторы**: статические фабрики (`of`, `from`, `valueOf`) удобнее, когда нужно кэшировать экземпляры.
5. **Документация**: описывайте ограничения, побочные эффекты и потокобезопасность через Javadoc и аннотации (`@ThreadSafe`).

## Паттерны проектирования
- **Creational**: Singleton (с Enum), Builder, Factory Method, Abstract Factory.
- **Structural**: Adapter, Decorator, Facade, Proxy.
- **Behavioral**: Strategy, Template Method, Observer, Command.

Практика: анализируйте стандартную библиотеку (например, `java.nio.file.Files` как фасад, `Collections.unmodifiableList` как
декоратор) и заимствуйте подходы.

## Работа с интерфейсами и абстракциями
С Java 8 интерфейсы поддерживают `default`-методы, что облегчает эволюцию API. Используйте `sealed` интерфейсы для ограниченных
иерархий, `static` методы для фабрик, `private` методы для реюза логики. Абстрактные классы храните для общих состояний и
защищённых хелперов.

## Архитектурные подходы
- **Domain-Driven Design** — агрегаты, value-объекты, репозитории.
- **Hexagonal Architecture** — разделение домена и адаптеров (портов).
- **Event-driven** — события как интерфейсы, обработчики как реализации.

Выбирайте архитектурный стиль исходя из требований проекта: DDD подходит для сложного домена, а модульные монолиты — для
приложений с единым деплоем, но разными bounded contexts.

## Практические упражнения
1. Спроектируйте систему заказов, выделив сущности, value-объекты и сервисы. Реализуйте агрегаты и примените паттерн Repository.
2. Реализуйте плагинную систему с пользовательскими `ClassLoader`, продемонстрируйте расширяемость через интерфейсы.
3. Напишите библиотеку конвертации валют, демонстрируя применение `Strategy` и иммутабельные объекты.

## Вопросы на собеседовании
1. **Когда лучше использовать композицию вместо наследования?**
   *Ответ:* Когда требуется повторное использование поведения без жёсткой иерархии. Композиция позволяет подменять компоненты,
   облегчает тестирование и снижает связанность.
2. **Как гарантировать неизменяемость класса?**
   *Ответ:* Сделать поля `private final`, не предоставлять сеттеры, копировать изменяемые аргументы и коллекции, объявить класс
   `final` или использовать `record`.
3. **В чём отличие интерфейса от абстрактного класса?**
   *Ответ:* Интерфейсы описывают контракт без состояния (кроме `static` и `default` методов), поддерживают множественное
   наследование. Абстрактные классы могут хранить состояние, предоставлять частичную реализацию, но наследуются только от одного
   базового класса.
4. **Как реализовать корректный паттерн Singleton?**
   *Ответ:* Использовать `enum Singleton { INSTANCE; }` или `private static class Holder`. Такие реализации потокобезопасны и
   поддерживают сериализацию.
5. **Что такое Liskov Substitution Principle и как его нарушить?**
   *Ответ:* Принцип требует, чтобы подкласс можно было использовать вместо базового класса без изменения корректности. Нарушение
   возникает, если подкласс ужесточает предусловия или ослабляет постусловия (например, метод `Square` переопределяет `setWidth`
   и ломает поведение базового `Rectangle`).
