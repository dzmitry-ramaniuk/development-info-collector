# Управление памятью и сборка мусора


## Содержание

1. [Модель памяти JVM](#модель-памяти-jvm)
2. [Типы сборщиков мусора](#типы-сборщиков-мусора)
3. [Жизненный цикл объекта](#жизненный-цикл-объекта)
4. [Настройка памяти и диагностика](#настройка-памяти-и-диагностика)
5. [Частые проблемы и подходы](#частые-проблемы-и-подходы)
6. [Практические советы](#практические-советы)
7. [Практические упражнения](#практические-упражнения)
8. [Вопросы на собеседовании](#вопросы-на-собеседовании)

## Модель памяти JVM
Java Memory Model (JMM) определяет, как потоки видят изменения и как работает кэширование значений. Внутри процесса память
разделена на кучу (heap), стеки потоков, метапространство и прочие структуры (direct buffer, off-heap кэш). Куча делится на
молодое поколение (Eden + survivor-области) и старшее поколение. Такое деление позволяет оптимизировать работу сборщика мусора,
поскольку большинство объектов живёт очень недолго и может очищаться копирующими алгоритмами.

## Типы сборщиков мусора
- **Serial GC** — однопоточный, подходит для небольших приложений и ограниченных сред.
- **Parallel GC** — использует несколько потоков для молодого и старшего поколений, обеспечивает высокую пропускную способность.
- **CMS (Concurrent Mark-Sweep)** — ранее популярный низкопаузный сборщик, с Java 14 удалён.
- **G1 GC** — региональный сборщик по умолчанию с Java 9+, стремится держать паузы в пределах цели (`-XX:MaxGCPauseMillis`).
- **ZGC и Shenandoah** — низколатентные сборщики с паузами в миллисекунды за счёт цветных указателей и concurrent compacting.

При выборе сборщика учитывайте характер нагрузки: для микросервисов с требованиями к задержкам — G1/ZGC, для батч-приложений —
Parallel GC.

## Жизненный цикл объекта
1. **Выделение** — поток записывает объект в TLAB; если буфер заполнен, происходит медленный путь через глобальный аллокатор.
2. **Promotion** — объект, переживший несколько minor-сборок, продвигается в старшее поколение. Настройка `-XX:MaxTenuringThreshold`
   помогает контролировать скорость продвижения.
3. **Сбор** — minor GC очищает Eden, major GC работает со старшим поколением. G1 выполняет смешанные циклы и может выбирать
   регионы с наибольшим эффектом очистки.

## Настройка памяти и диагностика
- **Размеры кучи**: `-Xms` (начальный) и `-Xmx` (максимальный). Хорошая практика — задавать их равными, чтобы избежать
  переразмеривания.
- **Metaspace**: контролируется `-XX:MaxMetaspaceSize`, диагностируется `jcmd VM.native_memory`.
- **Direct memory**: лимит `-XX:MaxDirectMemorySize`, полезно при активном использовании NIO.
- **GC-логи**: включайте `-Xlog:gc*` (Java 11+) или `-XX:+PrintGCDetails` (Java 8) для анализа пауз. Передайте логи в GC Easy или
  GarbageCat для визуализации.
- **Heap dump**: `jcmd GC.heap_dump` позволяет исследовать удерживаемые объёмы, деревья dominator и потенциальные утечки.

## Частые проблемы и подходы
- **OutOfMemoryError: Java heap space** — пересмотрите размеры кучи, найдите утечку (например, через кэш без ограничений).
- **OutOfMemoryError: Metaspace** — утечки классов из-за пользовательских class loader (часто в application servers). Нужно
  корректно освобождать class loader при hot deploy.
- **GC-паузы слишком длинные** — уменьшайте размер старшего поколения, настройте цели пауз, рассмотрите переход на другой сборщик.
- **Fragmentation** — для Parallel/Serial коллектора включайте `-XX:+UseStringDeduplication` и периодические full GC, для G1
  анализируйте смешанные циклы.

## Практические советы
- Измеряйте, а не угадывайте: включайте GC-логи на staging, смотрите распределение времени между young и mixed GC.
- Используйте профилировщики (VisualVM, YourKit, async-profiler) с режимом `alloc` для поиска горячих мест выделения.
- Ограничивайте коллекции, кэшируйте только необходимое, применяйте слабые/мягкие ссылки (`WeakReference`, `SoftReference`).
- При работе с большими массивами предпочитайте off-heap через `ByteBuffer.allocateDirect` или специализированные библиотеки.

## Практические упражнения
1. Напишите программу, которая создаёт много временных объектов, и сравните GC-логи для Parallel GC и G1.
2. Соберите heap dump после нагрузки, определите доминантные цепочки удержания и предложите оптимизации.
3. Попробуйте настроить `-XX:MaxGCPauseMillis` и посмотрите, как изменится поведение G1.

## Вопросы на собеседовании
1. **В чём отличие young и old поколения, и зачем нужны survivor-области?**
   *Ответ:* Молодое поколение обслуживает короткоживущие объекты; после каждой minor-сборки выжившие копируются в survivor-области.
   Объекты, пережившие несколько циклов, продвигаются в старшее поколение. Такое разделение уменьшает стоимость GC, потому что
   большинство объектов умирает рано.
2. **Как выбрать сборщик мусора для сервиса с низкими задержками?**
   *Ответ:* Рассмотреть G1 с настройкой пауз (`-XX:MaxGCPauseMillis`) или современные ZGC/Shenandoah, которые собирают кучу почти
   полностью в фоновом режиме и дают паузы порядка миллисекунд. Решение зависит от версии JDK и объёма кучи.
3. **Что такое stop-the-world и можно ли его избежать?**
   *Ответ:* stop-the-world — момент, когда JVM останавливает все прикладные потоки для выполнения операций GC или других задач
   (профилирование, safepoint). Полностью избежать нельзя, но можно сократить длительность, используя concurrent-алгоритмы и
   оптимизируя размер кучи.
4. **Как диагностировать утечку памяти в продакшене?**
   *Ответ:* Включить `-XX:+HeapDumpOnOutOfMemoryError`, снять heap dump, проанализировать его в MAT/VisualVM, найти цепочки
   удержания. Дополнительно снять серию JFR-трейсов, посмотреть аллокации и удерживаемые объёмы.
5. **Почему неконтролируемое создание потоков приводит к утечке памяти?**
   *Ответ:* Для каждого потока JVM выделяет стек (по умолчанию 1–2 МБ). Большое количество потоков увеличивает потребление памяти
   даже без работы GC. Решение — использовать пулы потоков и асинхронные библиотеки.
