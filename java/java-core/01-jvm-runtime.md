# Виртуальная машина и платформа Java


## Содержание

1. [Экосистема поставок и модульность платформы](#экосистема-поставок-и-модульность-платформы)
2. [Жизненный цикл Java-программы](#жизненный-цикл-java-программы)
3. [Архитектура памяти JVM](#архитектура-памяти-jvm)
4. [Ключевые компоненты исполнения](#ключевые-компоненты-исполнения)
   - [Интерпретатор и JIT](#интерпретатор-и-jit)
   - [Сборка мусора](#сборка-мусора)
   - [Безопасность и верификация](#безопасность-и-верификация)
5. [Инструменты и диагностика](#инструменты-и-диагностика)
6. [Типичные сценарии настройки](#типичные-сценарии-настройки)
7. [Практические упражнения](#практические-упражнения)
8. [Вопросы на собеседовании](#вопросы-на-собеседовании)

## Экосистема поставок и модульность платформы
Java Virtual Machine (JVM) — абстрактная вычислительная машина, исполняющая байт-код. Она поставляется в составе различных
дистрибутивов JDK (OpenJDK, Eclipse Temurin, Oracle JDK, Liberica) и в более лёгких JRE, предназначенных только для запуска
уже собранных приложений. С Java 9 ядро платформы построено вокруг модульной системы JPMS: стандартная библиотека разбита на
модули (`java.base`, `java.sql`, `jdk.management` и т.д.), что позволяет создавать кастомные рантаймы через `jlink` и
микросервисные поставки без лишних зависимостей.

**Историческая справка.** До Java 8 разработчики получали монолитный `rt.jar`, а инструменты вроде `jre` были обязательной
частью поставки. Модульность упростила декомпозицию, но одновременно потребовала явного описания зависимостей и добавила новые
инструменты (`jdeps`, `jmod`).

## Жизненный цикл Java-программы
1. **Написание и компиляция**. Исходники `.java` компилируются `javac` в байт-код `.class`. На этом этапе происходит проверка
   типов, разворачивание синтаксического сахара (автоупаковка, `for-each`) и формирование метаданных для отладки.
2. **Загрузка классов**. Работает иерархия загрузчиков: bootstrap поднимает базовые модули, platform отвечает за расширения, а
   application ищет классы приложения. Пользовательские загрузчики могут подгружать классы из сетевых хранилищ или шифрованных
   архивов, реализуя изоляцию плагинов.
3. **Верификация и подготовка**. Перед исполнением байт-код проверяется на корректность стека и типов, выполняются статические
   инициализаторы, создаются структуры данных в metaspace.
4. **Исполнение**. Интерпретатор запускает байт-код, профилирует горячие участки и передаёт их JIT-компилятору (C1, C2 или
   Graal). JIT оптимизирует код, применяя inlining, escape-анализ, удаление проверок. При неверных предположениях возможен
   deoptimization с возвратом к интерпретации.
5. **Завершение и мониторинг**. JVM обеспечивает хуки для graceful shutdown (`Runtime.addShutdownHook`), финализацию ресурсов,
   выгрузку классов. Встроенные инструменты (`jcmd`, Flight Recorder) собирают метрики и диагностические данные.

## Архитектура памяти JVM
- **Heap** — общая область объектов, управляемая сборщиком мусора. Разделяется на молодое и старшее поколение, может быть
  сегментирована (G1, ZGC, Shenandoah).
- **Stack** — набор фреймов для потоков исполнения, хранит локальные переменные и операнды.
- **Metaspace** — метаданные классов (структура полей, методов, runtime annotations). Размер метапространства можно лимитировать
  параметрами `-XX:MaxMetaspaceSize`.
- **Code cache** — область, куда JIT размещает скомпилированный машинный код.
- **Thread Local Allocation Buffers (TLAB)** — небольшие буферы в куче для каждого потока, ускоряющие выделение объектов.

Понимание архитектуры памяти помогает анализировать дампы (`jmap`, `jcmd GC.heap_info`), правильно настраивать `-Xms`,
`-Xmx`, параметры GC и выявлять утечки.

## Ключевые компоненты исполнения
### Интерпретатор и JIT
JVM стартует с интерпретации байт-кода. Когда метод становится горячим, профилировщик собирает статистику (частота вызовов,
ветвления) и передаёт метод JIT-компилятору. Клиентский компилятор C1 оптимизирует быстро и используется на ранних этапах.
Серверный компилятор C2 выполняет более тяжёлые оптимизации, а Graal (доступен с Java 11+) написан на Java и поддерживает
экспериментальные возможности (AOT-компиляция, GraalVM Native Image).

### Сборка мусора
Рантайм включает несколько сборщиков: Serial, Parallel, CMS (устаревший), G1, ZGC, Shenandoah. Выбор сборщика зависит от
требований к задержкам и throughput. Например, G1 делит кучу на регионы, собирает параллельно и инкрементально, контролирует
паузы через `-XX:MaxGCPauseMillis`. ZGC и Shenandoah обеспечивают низкие задержки за счёт цветных указателей и барьеров
записей/чтения.

### Безопасность и верификация
Security Manager (deprecated в Java 17) и механизм проверок классов препятствуют выполнению небезопасного кода. Система
подписанных JAR, модули `java.security` и `javax.crypto` обеспечивают контроль доступа и криптографию.

## Инструменты и диагностика
- **`javap`** — дизассемблирование байт-кода, анализ синтаксического сахара и оптимизаций.
- **`jlink` / `jpackage`** — сборка кастомных рантаймов и установочных пакетов.
- **JDK Mission Control / Java Flight Recorder** — запись профилей исполнения, событий GC, блокировок.
- **`jmap`, `jstack`, `jcmd`** — получение дампов памяти, потоков, мониторинга GC.
- **JVMTI-агенты** (async-profiler, YourKit) — низкоуровневая диагностика CPU, allocation, lock contention.

Практика: регулярно снимайте heap dump на стенде, чтобы понимать структуру объектов. Используйте JFR для анализа перфоманс
проблем перед выпуском релиза.

## Типичные сценарии настройки
- Серверные приложения на G1: `-Xms4g -Xmx4g -XX:+UseG1GC -XX:MaxGCPauseMillis=200` + включить `-XX:+PrintGCDetails` для
  мониторинга.
- Микросервисы: `jlink` для сборки минимального рантайма, ограничение метапространства.
- Нативная упаковка: `jpackage --type app-image` для десктопных приложений, дополнительно подписывайте бинарники.

## Практические упражнения
1. Создайте небольшое приложение, снимите байт-код через `javap -c` и определите, как разворачивается `switch`.
2. Снимите JFR-профиль под нагрузкой и найдите горячие методы, которые были JIT-компилированы.
3. Экспериментируйте с `jlink`, собрав рантайм только с модулями `java.base` и `java.sql`, и измерьте размер поставки.

## Вопросы на собеседовании
1. **Чем отличаются JDK, JRE и дистрибутивы OpenJDK?**
   *Ответ:* JRE содержит JVM и стандартные библиотеки для запуска приложения. JDK включает JRE и набор инструментов разработчика
   (`javac`, `jar`, `jlink`, `jpackage`, отладчики). Дистрибутивы OpenJDK отличаются политикой обновлений, поддерживаемыми
   платформами и дополнительными патчами, но реализуют одну спецификацию Java SE.
2. **Как устроена иерархия загрузчиков классов и зачем она нужна?**
   *Ответ:* Существует цепочка делегирования: bootstrap → platform → application → пользовательские загрузчики. Это обеспечивает
   безопасность (нельзя переопределить базовые классы), экономит память (классы переиспользуются) и даёт возможность
   изолировать плагины или динамически подгружать код.
3. **Что такое JIT-компиляция и когда происходит деоптимизация?**
   *Ответ:* JIT переводит горячие участки байт-кода в машинный код на основе профиля исполнения. Когда предположения компилятора
   нарушаются (например, метод стал полиморфным, изменилась структура класса), JVM откатывается к интерпретатору и пересобирает
   код заново — это и есть деоптимизация.
4. **Какие регионы памяти есть в JVM и чем они управляются?**
   *Ответ:* Heap (молодое/старшее поколения, TLAB), stack (фреймы потоков), metaspace (метаданные классов), code cache (JIT-код),
   off-heap структуры (direct buffers). Сборщик мусора управляет кучей и TLAB, ОС выделяет стек, metaspace управляется
   отдельным аллокатором и может ограничиваться параметрами `-XX:MaxMetaspaceSize`.
5. **Как с помощью инструментов JVM обнаружить утечку памяти?**
   *Ответ:* Снимите heap dump (`jcmd GC.heap_dump`), проанализируйте его в VisualVM или Eclipse MAT, найдите объекты с наибольшим
   удерживаемым объёмом. Используйте `jmap -histo` для оценки распределения классов, включите `-XX:+HeapDumpOnOutOfMemoryError`.
   Для динамического анализа применяйте JFR или async-profiler с режимом `alloc`.
