# Multithreading

## Модель памяти Java и синхронизация
- Java Memory Model (JMM) определяет правила видимости и порядок выполнения операций между потоками.
- Ключевые гарантии: *happens-before*, атомарность чтения/записи 64-битных значений при использовании `volatile` после Java 5.
- `volatile` обеспечивает видимость и упорядочивание, но не атомарность сложных операций.
- `synchronized` создаёт мониторный замок, гарантирует взаимное исключение и связь по happens-before (вход → выход из блока).

## Управление потоками
- Наследование от `Thread` против реализации `Runnable`/`Callable`: предпочтительно отделять задачу от механизма выполнения.
- `ExecutorService` предоставляет пулы потоков (`newFixedThreadPool`, `newCachedThreadPool`, `newWorkStealingPool`).
- Планирование задач: `ScheduledExecutorService`, `CompletableFuture` для декларативного описания асинхронных вычислений.
- Управление жизненным циклом: `shutdown`, `shutdownNow`, обработка `InterruptedException`, соглашения по прерыванию.

## Средства синхронизации и конкурентные структуры данных
- Высокоуровневые конструкции: `Lock`, `ReadWriteLock`, `StampedLock` (оптимистичное чтение).
- Синхронизаторы из `java.util.concurrent`: `CountDownLatch`, `CyclicBarrier`, `Semaphore`, `Exchanger`, `Phaser`.
- Неблокирующие алгоритмы: атомарные классы (`AtomicInteger`, `AtomicReference`), `LongAdder`, `ConcurrentHashMap`.
- Copy-on-write коллекции (`CopyOnWriteArrayList`, `CopyOnWriteArraySet`) для сценариев, где чтения преобладают над записями.

## Диагностика и проектирование многопоточных приложений
- Типичные проблемы: deadlock, livelock, starvation, race condition. Используйте блокировки с таймаутом, порядок захвата ресурсов.
- Инструменты: `jstack`, `jcmd Thread.print`, профилировщики (Java Flight Recorder, VisualVM) для анализа состояния потоков.
- Паттерны: Producer-Consumer, Future, Fork/Join, Reactor. Выбор зависит от модели нагрузки и требований к latency.
- Тестирование: `ThreadMXBean`, стресс-тесты с `jcstress`, использование `CountDownLatch` для воспроизведения гонок.

## Вопросы на собеседовании
1. **Что такое правило happens-before и зачем оно нужно?**
   - *Ответ:* Happens-before определяет отношение порядка между действиями в разных потоках. Если операция A happens-before операции B, то все эффекты A видны в B, что позволяет рассуждать о корректности синхронизации.
2. **Чем `volatile` отличается от `synchronized`?**
   - *Ответ:* `volatile` гарантирует видимость изменений и запрещает переупорядочивание, но не обеспечивает атомарность сложных операций. `synchronized` даёт взаимное исключение и полную синхронизацию, но может приводить к блокировкам и накладным расходам.
3. **Как правильно завершать работу `ExecutorService`?**
   - *Ответ:* Вызвать `shutdown()` для мягкой остановки, при необходимости дождаться завершения задач через `awaitTermination()`. Если требуется немедленная остановка — `shutdownNow()` и обработка `InterruptedException` внутри задач.
4. **Как работает `ConcurrentHashMap` и чем он лучше чем `Collections.synchronizedMap`?**
   - *Ответ:* `ConcurrentHashMap` делит структуру на сегменты (в современных версиях — на корзины с CAS), позволяет одновременные операции чтения и некоторые записи без полной блокировки. `synchronizedMap` использует глобальный монитор, что ограничивает параллелизм.
5. **Что такое deadlock и как его предотвратить?**
   - *Ответ:* Deadlock — взаимная блокировка потоков при захвате ресурсов. Предотвращается упорядочиванием захвата, использованием таймаутов (`tryLock`), избеганием длинных критических секций и анализом зависимостей.

