# Multithreading

## Java Memory Model и синхронизация
Java Memory Model (JMM) определяет, какие значения переменных видят потоки и в каком порядке выполняются операции. Отношение happens-before гарантирует, что все эффекты операции A будут видны операции B. Доступ к переменным без синхронизации может приводить к torn reads и кэшированию значений. Ключевое слово `volatile` обеспечивает видимость и запрещает опасные переупорядочивания, но не делает составные операции атомарными. `synchronized` создаёт монитор и устанавливает happens-before между входом и выходом, а также гарантирует взаимное исключение. Правильное использование синхронизации минимизирует гонки данных и позволяет рассуждать о корректности алгоритмов.

## Управление потоками и пулами
Создавать потоки напрямую через `new Thread` дорого: каждый поток требует стек и переключения контекста. Вместо этого используют `ExecutorService`, который переиспользует потоки и управляет очередью задач. Фиксированные пулы (`Executors.newFixedThreadPool`) подходят для CPU-bound задач, кэшируемые (`newCachedThreadPool`) — для большого числа коротких задач, планировщики (`newScheduledThreadPool`) выполняют задания по расписанию. `CompletableFuture` позволяет описывать асинхронные цепочки, комбинировать результаты (`thenCombine`, `allOf`) и обрабатывать исключения. Не забывайте корректно завершать пулы (`shutdown`, `awaitTermination`) и уважать флаг прерывания (`InterruptedException`).

## Синхронизаторы и конкурентные структуры данных
Пакет `java.util.concurrent` предоставляет инструменты высокого уровня: `Lock` и `ReentrantLock` позволяют управлять блокировками вручную, используя try-finally для освобождения. `ReadWriteLock` и `StampedLock` оптимизируют доступ, когда чтений больше, чем записей. Синхронизаторы `CountDownLatch`, `CyclicBarrier`, `Semaphore`, `Phaser` помогают координировать потоки. Для обмена данными без блокировок существуют атомарные типы (`AtomicInteger`, `AtomicReference`) и структуры вроде `ConcurrentHashMap`, `ConcurrentLinkedQueue`. Copy-on-write коллекции (`CopyOnWriteArrayList`) удобны, когда преобладают чтения.

## Проектирование и диагностика
Основные проблемы многопоточности — deadlock (взаимная блокировка), livelock (потоки заняты, но не продвигаются), starvation (один поток не получает ресурсы), race condition (несинхронизированный доступ). Для предотвращения deadlock задавайте порядок захвата блокировок, используйте таймауты (`tryLock`). Инструменты `jstack`, `jcmd Thread.print`, Java Flight Recorder позволяют снимать дампы потоков, видеть ожидания мониторов и долгие блокировки. Тестирование многопоточности требует стресс-тестов (`jcstress`), повторного запуска сценариев и применения барьеров (`CountDownLatch`) для воспроизведения гонок. При проектировании ориентируйтесь на неизменяемые объекты, отказоустойчивые очереди (например, `LinkedBlockingQueue`) и обработку ошибок в фоновых задачах.

## Шаблоны и практики
Паттерн Producer-Consumer реализует обмен данными через блокирующие очереди. Fork/Join (класс `ForkJoinPool`) разбивает задачи на подзадачи и объединяет результаты, эффективно задействуя ядра для divide-and-conquer алгоритмов. Reactor и другие реактивные модели обеспечивают неблокирующую обработку потоков событий. Для UI и серверных приложений важно избегать блокирующих вызовов в потоках обработки событий и использовать асинхронные API. Документируйте ожидания по потокам (какой поток вызывает метод) и придерживайтесь соглашения «владеющий поток отвечает за изменение состояния».

## Вопросы на собеседовании
1. **Что такое правило happens-before и почему оно важно?**  
   *Ответ:* Happens-before определяет порядок выполнения операций между потоками. Если A happens-before B, то все изменения, сделанные в A, гарантированно видны в B. Это позволяет рассуждать о корректности программы, не анализируя все возможные перестановки инструкций.
2. **Чем отличается `volatile` от `synchronized`?**  
   *Ответ:* `volatile` обеспечивает видимость и упорядочивание, но не гарантирует атомарность сложных операций. `synchronized` предоставляет взаимное исключение и полную синхронизацию, но может вызывать блокировки и накладные расходы. Часто `volatile` используют для флагов, а `synchronized` — для критических секций.
3. **Как правильно завершать работу `ExecutorService`?**  
   *Ответ:* Вызвать `shutdown()` для запрета новых задач и дождаться завершения текущих через `awaitTermination()`. При необходимости срочного завершения использовать `shutdownNow()`, прерывая работающие потоки, и корректно обрабатывать `InterruptedException` внутри задач.
4. **Что такое deadlock и как его обнаружить?**  
   *Ответ:* Deadlock — ситуация, когда несколько потоков ждут друг друга, и ни один не может продолжить работу. Обнаружить можно через `jstack` или `ThreadMXBean`, которые показывают цикл ожидания мониторов. Предотвращается упорядочиванием захвата ресурсов, использованием таймаутов и минимизацией времени удержания блокировок.
5. **Как использовать `CompletableFuture` для объединения результатов?**  
   *Ответ:* Методы `thenCombine`, `thenCompose`, `allOf`, `anyOf` позволяют объединять два или более асинхронных вычисления, комбинировать их результаты и обрабатывать ошибки. Это упрощает построение конвейеров обработки данных без ручного управления потоками.
