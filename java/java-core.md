# Java Core

## JVM, JRE и JDK
- **JVM** исполняет байт-код, предоставляет JIT-компиляцию, управление памятью (heap, stack, metaspace) и сборку мусора.
- **JRE** включает JVM и стандартные библиотеки, предназначен для запуска приложений.
- **JDK** = JRE + инструменты разработки (`javac`, `jlink`, `jpackage`, отладчики, профилировщики).
- Процесс запуска: `javac` компилирует `.java` в `.class`, загрузчики классов (bootstrap, extension, application) доставляют байт-код в JVM, после чего JIT и интерпретатор исполняют его.

## Управление памятью и сборка мусора
- Память делится на heap (объекты), stack (фреймы методов, примитивы, ссылки), metaspace (данные классов).
- Современные GC: Serial, Parallel, CMS (устаревший), G1, ZGC, Shenandoah. Выбор зависит от требований к latency и throughput.
- Жизненный цикл объекта: создание → использование → достижение состояния «не достижимый» → сборка мусора.
- Инструменты диагностики: `jmap`, `jcmd`, `jvisualvm`, Java Flight Recorder.

## Основы языка
- Примитивные типы и их обёртки; автоупаковка/распаковка, влияние на производительность.
- Ключевые слова управления потоком (`if`, `switch`, enhanced switch, циклы, try-with-resources).
- Модификаторы доступа (`private`, `default`, `protected`, `public`), ключевые слова `final`, `static`, `transient`, `volatile` (для полей), `strictfp`.
- Пакеты и модульность (JPMS): `module-info.java`, экспорт и импорт пакетов, `requires`/`exports`.

## Объектно-ориентированное программирование
- Классы, интерфейсы, записи (`record`), абстрактные классы и sealed-иерархии.
- Полиморфизм и позднее связывание: переопределение методов, `@Override`, `super`.
- Инкапсуляция, композиция, наследование; SOLID как общие рекомендации проектирования.
- Паттерны: Builder, Factory Method, Strategy, Template Method — часто применимы при проектировании Java-приложений.

## Коллекции и обобщения
- Иерархия `Collection`: `List`, `Set`, `Queue`, а также `Map` (не наследник `Collection`, но часть фреймворка).
- Списки: `ArrayList` (динамический массив), `LinkedList` (двусвязный список) — выбор на основе паттернов доступа.
- Множества: `HashSet`, `LinkedHashSet`, `TreeSet` (поддерживает сортировку через `Comparable`/`Comparator`).
- Карты: `HashMap`, `LinkedHashMap`, `TreeMap`, `EnumMap`. Особенности реализации хэш-таблиц (цепочки/деревья после Java 8).
- `Collections` и `Arrays` utility-классы: неизменяемые коллекции (`List.of`), методы сортировки, бинарный поиск.
- Обобщения (generics): инвариантность, wildcard (`? extends`, `? super`), стирание типов (type erasure).

## Работа с данными и ввод/вывод
- I/O (`java.io`): потоки байтов (`InputStream`, `OutputStream`) и символов (`Reader`, `Writer`).
- NIO.2 (`java.nio.file`): работа с путями (`Path`), неблокирующий ввод/вывод, `Files`, `FileVisitor`.
- Работа с сериализацией: стандартная (`Serializable`, `Externalizable`), альтернативы (JSON via Jackson, Gson, `record` для DTO).
- API для даты и времени (`java.time`): неизменяемые типы (`LocalDate`, `Instant`), `DateTimeFormatter`.

## Функциональные возможности языка
- Lambda-выражения и функциональные интерфейсы (`Function`, `Predicate`, `Supplier`, `Consumer`).
- Stream API: промежуточные и терминальные операции, ленивость вычислений, параллельные стримы.
- Optional как способ выразить отсутствие значения, основные методы (`of`, `ofNullable`, `map`, `flatMap`, `orElse`).
- Pattern Matching (instanceof с привязкой, switch pattern matching) — эволюция языка.

## Вопросы на собеседовании
1. **Объясните разницу между JVM, JRE и JDK.**
   - *Ответ:* JVM исполняет байт-код, JRE включает JVM и стандартные библиотеки для запуска, JDK добавляет инструменты разработки (компилятор, отладчики), позволяя создавать и упаковывать приложения.
2. **Что такое сборка мусора и какие алгоритмы используются в современных реализациях Java?**
   - *Ответ:* GC автоматически освобождает память от недостижимых объектов. Современные сборщики: G1 (поколенческий, региональный), ZGC и Shenandoah (низкие задержки), Parallel (максимальный throughput). Выбор зависит от SLA по задержкам и пропускной способности.
3. **Чем отличаются `ArrayList` и `LinkedList` и когда выбрать один из них?**
   - *Ответ:* `ArrayList` основан на динамическом массиве, эффективен для случайного доступа и добавления в конец. `LinkedList` — двусвязный список, выгоден при частых вставках/удалениях в середине, но проигрывает по локальности памяти.
4. **Что такое стирание типов и как оно влияет на работу generics?**
   - *Ответ:* При компиляции параметрические типы заменяются на их границы (обычно `Object`), что обеспечивает совместимость с кодом до Java 5. В runtime информация о типах отсутствует, нельзя, например, создать `new T[]` или использовать `instanceof List<String>`.
5. **Как работает `try-with-resources` и какие требования предъявляются к ресурсам?**
   - *Ответ:* Конструкция автоматически закрывает ресурсы после выполнения блока. Ресурс должен реализовывать `AutoCloseable`. Закрытие выполняется в обратном порядке объявления, исключения из `close()` добавляются как подавленные.
6. **В чём разница между `==` и `equals()` при сравнении объектов?**
   - *Ответ:* `==` сравнивает ссылки (адреса) объектов. `equals()` может быть переопределён для логического сравнения по содержимому. Для корректности нужно переопределять `hashCode()` согласованно с `equals()`.

