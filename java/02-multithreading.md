# Multithreading

## Java Memory Model и гарантии видимости
Java Memory Model (JMM) описывает, какие значения переменных могут наблюдать потоки и какие переупорядочивания допустимы.
Отношение happens-before гарантирует, что операции до него становятся видимыми операциям после. Ключевые источники
happens-before:
- завершение одного потока и `Thread.join()` в другом;
- запись в `volatile` и последующее чтение той же переменной;
- вход/выход из синхронизированного блока (`synchronized`);
- завершение конструктора до публикации ссылки на объект.

Без синхронизации компилятор и процессор могут переупорядочивать инструкции, что приводит к гонкам и непредсказуемым
значениям (`torn reads`, кэширование регистров). Ключевое слово `volatile` обеспечивает видимость и упорядочивание, но не
делает сложные операции (инкремент, проверка-далее-действие) атомарными. Для атомарности используйте `synchronized`, `Lock`
или атомарные типы.

## Управление потоками и пулами
Создание большого количества потоков дорого: каждый поток получает стек (1–2 МБ) и участвует в переключении контекста. Вместо
`new Thread` используйте пулы `ExecutorService`:
- `Executors.newFixedThreadPool(n)` — фиксированное количество потоков для CPU-bound задач.
- `newCachedThreadPool()` — динамический пул для большого числа коротких задач.
- `newScheduledThreadPool()` — планирование отложенных и периодических задач.
- `ForkJoinPool` — специализированный пул для рекурсивных divide-and-conquer алгоритмов.

Работая с `ExecutorService`, всегда корректно завершавайте его (`shutdown`, `awaitTermination`) и уважайте флаг прерывания:
проверяйте `Thread.currentThread().isInterrupted()` или ловите `InterruptedException`.

## Асинхронные вычисления и координация
- **`CompletableFuture`** — строит цепочки задач (`thenApply`, `thenCompose`, `handle`), позволяет комбинировать результаты
  (`thenCombine`, `allOf`) и переключать исполнителей (`supplyAsync(..., executor)`).
- **Structured concurrency** (Java 21) вводит `StructuredTaskScope`, который автоматически управляет дочерними задачами и
  отменяет их при ошибках.
- **Project Loom** (Java 21) добавил виртуальные потоки — легковесные задачи, которые снимают необходимость в сложных пулах.

## Синхронизаторы и конкурентные структуры данных
- **Locks**: `ReentrantLock` предоставляет методы `lock`, `tryLock`, `lockInterruptibly`. `ReadWriteLock` разделяет доступ на
  читателей/писателей, `StampedLock` имеет оптимистичное чтение.
- **Синхронизаторы**: `CountDownLatch` (ожидание N событий), `CyclicBarrier` (синхронизация фаз), `Semaphore` (ограничение
  ресурсов), `Phaser` (динамические участники).
- **Атомарные типы**: `AtomicInteger`, `AtomicReference`, `LongAdder` (оптимизирован для частых инкрементов).
- **Очереди**: `LinkedBlockingQueue`, `ArrayBlockingQueue`, `SynchronousQueue`, `PriorityBlockingQueue`. Для lock-free сценариев —
  `ConcurrentLinkedQueue`, `ConcurrentLinkedDeque`.
- **Коллекции**: `ConcurrentHashMap` с атомарными методами (`computeIfAbsent`, `merge`), `CopyOnWriteArrayList` для сценариев с
  преобладанием чтения.

## Потоковое локальное состояние и неизменяемость
`ThreadLocal` позволяет хранить состояние, привязанное к потоку (например, форматтеры дат). Используйте его осторожно и очищайте
значения (`remove`), особенно в пулах потоков. Предпочитайте иммутабельные объекты и передачу данных через сообщения — это снижает
количество блокировок.

## Диагностика и устранение проблем
Основные антипаттерны:
- **Deadlock** — потоки ждут ресурсы друг друга. Предотвращайте фиксированным порядком захвата, таймаутами `tryLock`.
- **Livelock** — потоки постоянно реагируют на состояние других, но не продвигаются. Решение — случайные задержки, backoff.
- **Starvation** — поток никогда не получает ресурс. Используйте справедливые блокировки (`new ReentrantLock(true)`), разделяйте
  пулы по типу задач.
- **Race condition** — некорректный доступ к разделяемым данным. Лечится синхронизацией или неизменяемыми структурами.

Инструменты диагностики: `jstack`, `jcmd Thread.print`, VisualVM, Java Flight Recorder, `async-profiler` (режим `lock`). Для
проверки конкуренции применяйте `jcstress`, повторный запуск тестов, Chaos Monkey для многопоточности.

## Шаблоны и практические приёмы
- **Producer-Consumer**: обмен через `BlockingQueue`, контроль backpressure.
- **Worker Pool**: центральная очередь задач и группа потоков; удобно для API обработки запросов.
- **Fork/Join**: рекурсивное деление задач (например, параллельная сортировка, обработка массивов).
- **Reactive Streams**: Flow API и фреймворки (Reactor, RxJava) реализуют асинхронную обработку событий с контролем скорости.
- **Параллельные коллекции**: `Arrays.parallelSort`, `Stream.parallel` — используйте, когда операции ассоциативны и не требуют
  совместного состояния.

## Практические упражнения
1. Реализуйте производитель-потребитель с `BlockingQueue`, добавьте ограничение скорости через `Semaphore`.
2. Напишите сервис, который выполняет несколько HTTP-запросов параллельно с использованием `CompletableFuture` и обрабатывает
   отмену при тайм-ауте.
3. Смоделируйте deadlock, затем устраните его, внедрив упорядочивание блокировок и логику backoff.

## Вопросы на собеседовании
1. **Что такое правило happens-before и почему оно важно?**
   *Ответ:* Happens-before задаёт порядок операций между потоками. Если действие A happens-before B, то все изменения, сделанные в
   A, гарантированно видны в B. Это позволяет рассуждать о корректности кода, игнорируя внутренние переупорядочивания процессора.
2. **Чем отличается `volatile` от `synchronized`?**
   *Ответ:* `volatile` обеспечивает видимость и запрещает опасные переупорядочивания, но не гарантирует атомарность сложных
   операций. `synchronized` обеспечивает взаимное исключение и полную синхронизацию между потоками, но вводит блокировки и
   накладные расходы.
3. **Как правильно завершать работу `ExecutorService`?**
   *Ответ:* Вызвать `shutdown()` для запрета новых задач, затем `awaitTermination()` с таймаутом. При необходимости срочного
   останова применить `shutdownNow()` и корректно обработать `InterruptedException` внутри задач.
4. **Что такое deadlock и как его обнаружить?**
   *Ответ:* Deadlock — ситуация, когда несколько потоков ждут друг друга и никто не может продолжить. Выявляется через `jstack`
   или `ThreadMXBean#findDeadlockedThreads`, которые показывают циклы ожидания мониторов. Избегайте, соблюдая единый порядок
   захвата блокировок и минимизируя время удержания.
5. **Как `CompletableFuture` помогает строить асинхронные конвейеры?**
   *Ответ:* Он поддерживает комбинаторы (`thenCombine`, `thenCompose`, `allOf`), позволяющие объединять независимые задачи,
   обрабатывать ошибки (`exceptionally`, `handle`) и настраивать исполнителей. Это избавляет от ручного управления потоками и
   коллбэками.
