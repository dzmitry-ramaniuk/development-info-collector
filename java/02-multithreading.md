# Multithreading: структура материала


## Содержание

1. [Историческая справка](#историческая-справка)
2. [Дорожная карта глав](#дорожная-карта-глав)
3. [Рекомендации по изучению](#рекомендации-по-изучению)

Многопоточность (multithreading) — одна из ключевых особенностей Java с момента её создания. Современная Java предоставляет богатый набор инструментов для построения конкурентных приложений: от низкоуровневых примитивов до высокоуровневых абстракций асинхронного программирования.

Материал разбит на тематические главы, которые можно изучать последовательно или обращаться к конкретным темам при необходимости. Каждая глава содержит практические примеры кода, объяснения концепций и типичные паттерны использования.

## Историческая справка

Java изначально проектировалась как язык с встроенной поддержкой многопоточности. В Java 1.0 (1996) появились классы `Thread`, `Runnable` и ключевое слово `synchronized`. Это был значительный шаг вперёд по сравнению с C/C++, где многопоточность зависела от платформы.

**Основные вехи эволюции:**
- **Java 1.0-1.4**: Базовые примитивы (`Thread`, `synchronized`, `wait/notify`). Модель памяти имела серьёзные недостатки.
- **Java 5 (2004)**: Революционное обновление — появился пакет `java.util.concurrent` (JSR-166) от Doug Lea. Добавлены `ExecutorService`, `Lock`, `Semaphore`, `CountDownLatch`, `ConcurrentHashMap`, атомарные классы. Переработана Java Memory Model (JSR-133).
- **Java 7 (2011)**: `ForkJoinPool` и `RecursiveTask` для параллельных вычислений.
- **Java 8 (2014)**: `CompletableFuture` для асинхронного программирования, параллельные стримы.
- **Java 9-17**: Улучшения `CompletableFuture`, reactive streams (Flow API), оптимизации `ConcurrentHashMap`.
- **Java 19-21 (2023)**: Виртуальные потоки (Project Loom), structured concurrency — революция в асинхронном программировании.

## Дорожная карта глав

1. [Java Memory Model и гарантии видимости](multithreading/01-jmm-visibility.md) — модель памяти JVM, happens-before, volatile и проблемы синхронизации.
2. [Управление потоками и пулами](multithreading/02-thread-pools.md) — ExecutorService, ForkJoinPool, виртуальные потоки, управление жизненным циклом.
3. [Асинхронные вычисления и координация](multithreading/03-async-coordination.md) — CompletableFuture, Structured Concurrency, построение асинхронных конвейеров.
4. [Синхронизаторы и конкурентные структуры данных](multithreading/04-synchronizers.md) — Lock, ReadWriteLock, StampedLock, CountDownLatch, CyclicBarrier, Semaphore, Phaser, атомарные типы, ConcurrentHashMap, BlockingQueue.
5. [Потоковое локальное состояние и неизменяемость](multithreading/05-threadlocal-immutability.md) — ThreadLocal, InheritableThreadLocal, неизменяемые объекты, Records.
6. [Диагностика и устранение проблем](multithreading/06-diagnostics-problems.md) — deadlock, livelock, starvation, race conditions, инструменты диагностики (jstack, jcmd, JFR), тестирование конкурентного кода.
7. [Шаблоны и практические приёмы](multithreading/07-patterns.md) — Producer-Consumer, Worker Pool, Fork/Join, Reactive Streams, Double-Checked Locking, Thread-Per-Message, параллельные коллекции.
8. [Практические упражнения](multithreading/08-exercises.md) — задачи для закрепления материала с подсказками по реализации.
9. [Вопросы на собеседовании](multithreading/09-interview-questions.md) — типичные вопросы с детальными ответами и примерами кода.

## Рекомендации по изучению

1. **Начните с основ**: Изучите Java Memory Model и понимание happens-before — это фундамент для рассуждения о корректности многопоточного кода.
2. **Практикуйте постепенно**: Начните с простых ExecutorService, затем переходите к более сложным конструкциям вроде CompletableFuture и Fork/Join.
3. **Изучайте паттерны**: Понимание типичных паттернов (Producer-Consumer, Worker Pool) поможет быстро находить решения.
4. **Диагностируйте проблемы**: Научитесь выявлять и устранять deadlock, race conditions и другие проблемы конкуренции.
5. **Решайте упражнения**: Практические задания помогут закрепить теорию и понять нюансы реализации.
6. **Готовьтесь к собеседованиям**: Используйте раздел вопросов для самопроверки и повторения ключевых тем.

> **Современная многопоточность.** С появлением виртуальных потоков (Java 19+) и Structured Concurrency (Java 21+) подход к написанию конкурентного кода меняется. Виртуальные потоки позволяют писать простой синхронный код вместо сложных асинхронных конструкций, сохраняя при этом высокую производительность. Изучайте как классические подходы (для поддержки legacy кода), так и современные возможности платформы.
